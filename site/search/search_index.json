{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to Simpl\n\n\nThe Simpl framework is composed of three major parts:\n\n\n\n\n\n\nThe \nSimpl-Games-API\n service: a single instance running for all simulations, providing user information and storage to the model services\n\n\n\n\n\n\nThe \nSimpl-modelservice\n Python framework used to build simulation model services.\n\n\n\n\n\n\nThe \nSimpl-react\n npm module, a module providing components for building UIs that interact with a simulation model service.\n\n\n\n\n\n\nSome repos are provided as examples of how to build simulations using Simpl:\n\n\n\n\n\n\nsimpl-calc-model\n is an example of a single player simulation model service.\n\n\n\n\n\n\nsimpl-calc-ui\n is an example of a browser-based UI for a single player simulation model service.",
            "title": "Welcome to Simpl"
        },
        {
            "location": "/#welcome-to-simpl",
            "text": "The Simpl framework is composed of three major parts:    The  Simpl-Games-API  service: a single instance running for all simulations, providing user information and storage to the model services    The  Simpl-modelservice  Python framework used to build simulation model services.    The  Simpl-react  npm module, a module providing components for building UIs that interact with a simulation model service.    Some repos are provided as examples of how to build simulations using Simpl:    simpl-calc-model  is an example of a single player simulation model service.    simpl-calc-ui  is an example of a browser-based UI for a single player simulation model service.",
            "title": "Welcome to Simpl"
        },
        {
            "location": "/overview/",
            "text": "Overview\n\n\nIn practice, there will always be a single instance of The \nSimpl-Games-API\n service, and for every simulation you\nwill write a model service, and a frontend service. The browser will use the frontend service for the static assets\n(HTML and JS), to authenticate users,  and to connect to the model service in order to receive/send events through the WebSocket.\n\n\nThe \nSimpl-Games-API\n service will send events to your model service via HTTP Webhooks, and they will be\nautomatically forwarded to the browser.\n\n\nYour model service will send messages to the browser or listen to messages from it, and will make\nREST API calls to the \nSimpl-Games-API\n service as needed (eg to store state).\n\n\n    +-------------------------------------------------+\n    |                `Simpl-Games-API`                |\n    +-------------------------------------------------+\n              | A                         | A\n     Webhooks | |  REST API      Webhooks | |  REST API\n              V |                         V |\n   +-------------------+          +-------------------+ \n   | modelservice sim1 |          | modelservice sim2 | \n   +-------------------+          +-------------------+\n        A           A                 A           A\n        | WAMP      | WAMP            | WAMP      | WAMP\n        V           V                 V           V\n+-----------+  +-----------+  +-----------+  +-----------+\n| Browser 1 |  | Browser 2 |  | Browser 3 |  | Browser 4 |\n+-----------+  +-----------+  +-----------+  +-----------+\n     A               A             A               A\n     | Static        | Static      | Static        | Static\n     | assets        | assets      | assets        | assets\n   +-------------------+         +-------------------+ \n   |   frontend sim1   |         |   frontend sim2   | \n   +-------------------+         +-------------------+\n\n\n\n\n\nThe WAMP Layer\n\n\nThe communication between the modelservice and the browser happens via Websocket by using the \nWAMP Protocol\n.\n\n\nThw WAMP Protocol is mainly composed of two patterns: publish/subscribe (\nPubSub\n in short) and call/register (or \nRPC\n).\n\n\nPubSub vs RPC\n\n\nThe main difference between PubSub and RPC is that a \ncall\n to a registered procedure returns a value,\nwhere \npublishing\n to a topic does not. Both are asynchronous operations, but with RPC you can wait on the returned value\nto tell when the operation has completed.\n\n\nAs a rule of thumb: use RPC if you need to get data from the modelservice or wait until the procedure has completed before proceeding.\nOtherwise you can use PubSub.",
            "title": "Overview"
        },
        {
            "location": "/overview/#overview",
            "text": "In practice, there will always be a single instance of The  Simpl-Games-API  service, and for every simulation you\nwill write a model service, and a frontend service. The browser will use the frontend service for the static assets\n(HTML and JS), to authenticate users,  and to connect to the model service in order to receive/send events through the WebSocket.  The  Simpl-Games-API  service will send events to your model service via HTTP Webhooks, and they will be\nautomatically forwarded to the browser.  Your model service will send messages to the browser or listen to messages from it, and will make\nREST API calls to the  Simpl-Games-API  service as needed (eg to store state).      +-------------------------------------------------+\n    |                `Simpl-Games-API`                |\n    +-------------------------------------------------+\n              | A                         | A\n     Webhooks | |  REST API      Webhooks | |  REST API\n              V |                         V |\n   +-------------------+          +-------------------+ \n   | modelservice sim1 |          | modelservice sim2 | \n   +-------------------+          +-------------------+\n        A           A                 A           A\n        | WAMP      | WAMP            | WAMP      | WAMP\n        V           V                 V           V\n+-----------+  +-----------+  +-----------+  +-----------+\n| Browser 1 |  | Browser 2 |  | Browser 3 |  | Browser 4 |\n+-----------+  +-----------+  +-----------+  +-----------+\n     A               A             A               A\n     | Static        | Static      | Static        | Static\n     | assets        | assets      | assets        | assets\n   +-------------------+         +-------------------+ \n   |   frontend sim1   |         |   frontend sim2   | \n   +-------------------+         +-------------------+",
            "title": "Overview"
        },
        {
            "location": "/overview/#the-wamp-layer",
            "text": "The communication between the modelservice and the browser happens via Websocket by using the  WAMP Protocol .  Thw WAMP Protocol is mainly composed of two patterns: publish/subscribe ( PubSub  in short) and call/register (or  RPC ).",
            "title": "The WAMP Layer"
        },
        {
            "location": "/overview/#pubsub-vs-rpc",
            "text": "The main difference between PubSub and RPC is that a  call  to a registered procedure returns a value,\nwhere  publishing  to a topic does not. Both are asynchronous operations, but with RPC you can wait on the returned value\nto tell when the operation has completed.  As a rule of thumb: use RPC if you need to get data from the modelservice or wait until the procedure has completed before proceeding.\nOtherwise you can use PubSub.",
            "title": "PubSub vs RPC"
        },
        {
            "location": "/getting_started/",
            "text": "Simpl Getting Started Guide\n\n\nYou can get a taste of Simpl by running the simpl-calc example simulation.\n\n\nPrerequisites\n\n\nThese instructions assume you are working in the Simpl Vagrant environment:\n\n\n\n\nSimpl Python-Dev Development Environment (CentOS 7) Vagrant Box\n\n\nPostgreSQL >= 9.6\n\n\nPython >= 3.6\n\n\n\n\n\n\n\n\nClone and run the Simpl \npython-vagrant-centos7\n image:\n\n\ngit clone git@github.com:simplworld/python-vagrant-centos7.git\ncd python-vagrant-centos7\nvagrant up\n\n\n\n\n\nRun the Simpl Games API Service\n\n\nClone the simpl-games-api repository in the Vagrant image's project directory:\n\n\ncd python-vagrant-centos7/projects\ngit clone git@github.com:simplworld/simpl-games-api.git\n\n\n\n\n\nConnect to the Vagrant environment and install simpl-games-api:\n\n\nvagrant ssh\nmkvirtualenv simpl-games-api\ncd projects/simpl-games-api\nadd2virtualenv .\npip install -r requirements.txt\n\n\n\n\n\nCreate a Simpl database:\n\n\ncreatedb simpl\n./manage.py migrate\n./manage.py create_simpl_user\n\n\n\n\n\nStart the simpl-games-api web service:\n\n\n./manage.py run_gunicorn\n\n\n\n\n\nRun the Simpl Calc Model Service\n\n\nIn a separate terminal, clone the simpl-calc-model repository in the Vagrant image's project directory:\n\n\ncd python-vagrant-centos7/projects\ngit clone git@github.com:simplworld/simpl-calc-model.git\n\n\n\n\n\nConnect to Vagrant environment and install the simpl-calc Model Service:\n\n\nvagrant ssh\nmkvirtualenv simpl-calc-model\ncd projects/simpl-calc-model\nadd2virtualenv .\nPIP_PROCESS_DEPENDENCY_LINKS=1 pip install -r requirements.txt\n\n\n\n\n\nAdd the simp-calc game to the Simpl database along with some test users:\n\n\n./manage.py create_default_env\n\n\n\n\n\nStart service by running:\n\n\n./manage.py run_modelservice\n\n\n\n\n\nBy default the service will bind to \n0.0.0.0:8080\n.\n\n\nRun the Simpl Calc Frontend UI\n\n\nIn a separate terminal, clone the simpl-calc-ui repository in the Vagrant image's project directory:\n\n\ncd python-vagrant-centos7/projects\ngit clone git@github.com:simplworld/simpl-calc-ui.git\n\n\n\n\n\nConnect to Vagrant environment and install the simpl-calc Front End\n\n\nvagrant ssh\nmkvirtualenv simpl-calc-ui\ncd projects/simpl-calc-ui\nadd2virtualenv .\npip install -r requirements.txt\n./manage.py migrate\n\n\n\n\n\nStart your frontend webserver with:\n\n\n./manage.py runserver 0.0.0.0:8000\n\n\n\n\n\nInstall gulp and/or webpack globally outside Vagrant to ensure they are on your PATH\n\n\nsudo npm install --global webpack\nsudo npm install --global gulp\n\n\n\n\n\nIn a separate terminal, update node_modules and run Gulp to compile JS and SASS\n\n\ncd to simpl-calc-ui directory\nnpm install\ngulp\n\n\n\n\n\nUsing the Simpl Calc Simulation\n\n\nThe simpl-cal simulation is now running at \nhttp://localhost:8000/\n\n\nLog in player s1@calc.edu (password s1) or player s2@calc.edu (password s2). Once logged in, use the simulation to add numbers to a total.\n\n\nIn another browser, log in as leader@calc.edu (password leader) to see the player totals update over time.",
            "title": "Running a Simpl Simulation"
        },
        {
            "location": "/getting_started/#simpl-getting-started-guide",
            "text": "You can get a taste of Simpl by running the simpl-calc example simulation.",
            "title": "Simpl Getting Started Guide"
        },
        {
            "location": "/getting_started/#prerequisites",
            "text": "These instructions assume you are working in the Simpl Vagrant environment:   Simpl Python-Dev Development Environment (CentOS 7) Vagrant Box  PostgreSQL >= 9.6  Python >= 3.6     Clone and run the Simpl  python-vagrant-centos7  image:  git clone git@github.com:simplworld/python-vagrant-centos7.git\ncd python-vagrant-centos7\nvagrant up",
            "title": "Prerequisites"
        },
        {
            "location": "/getting_started/#run-the-simpl-games-api-service",
            "text": "Clone the simpl-games-api repository in the Vagrant image's project directory:  cd python-vagrant-centos7/projects\ngit clone git@github.com:simplworld/simpl-games-api.git  Connect to the Vagrant environment and install simpl-games-api:  vagrant ssh\nmkvirtualenv simpl-games-api\ncd projects/simpl-games-api\nadd2virtualenv .\npip install -r requirements.txt  Create a Simpl database:  createdb simpl\n./manage.py migrate\n./manage.py create_simpl_user  Start the simpl-games-api web service:  ./manage.py run_gunicorn",
            "title": "Run the Simpl Games API Service"
        },
        {
            "location": "/getting_started/#run-the-simpl-calc-model-service",
            "text": "In a separate terminal, clone the simpl-calc-model repository in the Vagrant image's project directory:  cd python-vagrant-centos7/projects\ngit clone git@github.com:simplworld/simpl-calc-model.git  Connect to Vagrant environment and install the simpl-calc Model Service:  vagrant ssh\nmkvirtualenv simpl-calc-model\ncd projects/simpl-calc-model\nadd2virtualenv .\nPIP_PROCESS_DEPENDENCY_LINKS=1 pip install -r requirements.txt  Add the simp-calc game to the Simpl database along with some test users:  ./manage.py create_default_env  Start service by running:  ./manage.py run_modelservice  By default the service will bind to  0.0.0.0:8080 .",
            "title": "Run the Simpl Calc Model Service"
        },
        {
            "location": "/getting_started/#run-the-simpl-calc-frontend-ui",
            "text": "In a separate terminal, clone the simpl-calc-ui repository in the Vagrant image's project directory:  cd python-vagrant-centos7/projects\ngit clone git@github.com:simplworld/simpl-calc-ui.git  Connect to Vagrant environment and install the simpl-calc Front End  vagrant ssh\nmkvirtualenv simpl-calc-ui\ncd projects/simpl-calc-ui\nadd2virtualenv .\npip install -r requirements.txt\n./manage.py migrate  Start your frontend webserver with:  ./manage.py runserver 0.0.0.0:8000  Install gulp and/or webpack globally outside Vagrant to ensure they are on your PATH  sudo npm install --global webpack\nsudo npm install --global gulp  In a separate terminal, update node_modules and run Gulp to compile JS and SASS  cd to simpl-calc-ui directory\nnpm install\ngulp",
            "title": "Run the Simpl Calc Frontend UI"
        },
        {
            "location": "/getting_started/#using-the-simpl-calc-simulation",
            "text": "The simpl-cal simulation is now running at  http://localhost:8000/  Log in player s1@calc.edu (password s1) or player s2@calc.edu (password s2). Once logged in, use the simulation to add numbers to a total.  In another browser, log in as leader@calc.edu (password leader) to see the player totals update over time.",
            "title": "Using the Simpl Calc Simulation"
        },
        {
            "location": "/tutorials/single-player/",
            "text": "Single Player Tutorial\n\n\nThis tutorial will walk you through the creation of the Calc game.\nThis game implements a model that takes a number and adds it to a current total.\nThis project, though basic, will demonstrate how the various pieces of Simpl interact to provide a platform\nupon which single player games can be created.\n\n\nThe foundation of Simpl is the Games API Service.  This service provides API endpoints that allow the game\nto store information regarding a game and its current state in the database. Start by running the\nSimpl Games API Service following the \ngetting started instructions\n.\n\n\nThe Model Service provides the mathematical component of a Simpl game, it interacts with the Games API and\nprovides messaging back to the Frontend UI regarding game state.  More information can be found \nhere\n.\n\n\nFirst, we'll implement our Model Service, giving us our mathematical model for Simpl Calc.\nNext, we'll build the user-facing pieces.\n\n\n\n\nBuild the Single Player Model Service\n\n\nBuild the Single Player Frontend UI",
            "title": "Single Player Example"
        },
        {
            "location": "/tutorials/single-player/#single-player-tutorial",
            "text": "This tutorial will walk you through the creation of the Calc game.\nThis game implements a model that takes a number and adds it to a current total.\nThis project, though basic, will demonstrate how the various pieces of Simpl interact to provide a platform\nupon which single player games can be created.  The foundation of Simpl is the Games API Service.  This service provides API endpoints that allow the game\nto store information regarding a game and its current state in the database. Start by running the\nSimpl Games API Service following the  getting started instructions .  The Model Service provides the mathematical component of a Simpl game, it interacts with the Games API and\nprovides messaging back to the Frontend UI regarding game state.  More information can be found  here .  First, we'll implement our Model Service, giving us our mathematical model for Simpl Calc.\nNext, we'll build the user-facing pieces.   Build the Single Player Model Service  Build the Single Player Frontend UI",
            "title": "Single Player Tutorial"
        },
        {
            "location": "/tutorials/single-player/modelservice/",
            "text": "Building the Model Service implementation\n\n\nPrerequisites\n\n\n\n\nNote\n\n\nThis tutorial assumes you have \nGames API service\n running (http://localhost:8100/) on a Vagrant box you have provisioned.  Please open up an additional terminal window before continuing.\n\n\n\n\nInstallation\n\n\nFirst, log into Vagrant and create a new virtualenv called 'calc-model':\n\n\n$ vagrant ssh\n$ mkvirtualenv calc-model\n\n\n\n\n\nInstall Django\n\n\n$ pip install \nDjango\n==\n1\n.11.11\n\n\n\n\n\nChange to the projects folder:\n\n\n$ \ncd\n projects\n\n\n\n\n\nCreate a Django project folder and rename it to serve as a git repository\n\n\n$ django-admin startproject calc_model\n$ mv calc_model calc-model\n\n\n\n\n\nChange to the project folder:\n\n\n$ \ncd\n calc-model\n$ add2virtualenv .\n\n\n\n\n\nCreate a \nrequirements.txt\n file that installs the simpl-modelservice and unit testing apps:\n\n\nhttps://github.com:simplworld/simpl-modelservice/repository/archive.zip\n\n# tests\npytest==3.1.3\npytest-cov==2.5.1\npytest-django==3.1.2\ndjango-test-plus==1.0.22\n\n\n\n\n\nInstall these requirements along with their dependencies:\n\n\n$ \nPIP_PROCESS_DEPENDENCY_LINKS\n=\n1\n pip install -r requirements.txt\n\n\n\n\n\nPlease note, if \nDJANGO_SETTINGS_MODULE\n is leftover from a previous session, you may need to unset it:\n\n\n$ \nunset\n DJANGO_SETTINGS_MODULE\n\n\n\n\n\nCreate a django app that will contain your game logic:\n\n\n$ ./manage.py startapp game\n\n\n\n\n\nAdd the following to your \nINSTALLED_APPS\n in \ncalc_model/settings.py\n:\n\n\nINSTALLED_APPS\n \n+=\n \n[\n\n    \n...\n\n\n    \n'modelservice'\n,\n\n    \n'rest_framework'\n,\n\n\n    \n'game'\n,\n\n\n]\n\n\n\nCALLBACK_URL\n \n=\n \nos\n.\nenviron\n.\nget\n(\n'CALLBACK_URL'\n,\n \n'http://{hostname}:{port}/callback'\n)\n\n\n\nSIMPL_GAMES_URL\n \n=\n \nos\n.\nenviron\n.\nget\n(\n'SIMPL_GAMES_URL'\n,\n \n'http://localhost:8100/apis'\n)\n\n\n\nSIMPL_GAMES_AUTH\n \n=\n \n(\n'simpl@simpl.world'\n,\n \n'simpl'\n)\n\n\n\nROOT_TOPIC\n \n=\n \n'world.simpl.sims.calc'\n\n\n\n\n\n\nIt's highly recommended that you set a \n'users'\n cache. Since the modelservice will run single-threaded, you can take advantage of the \nlocmem\n backend:\n\n\nCACHES = {\n    'default': {\n        'BACKEND': 'django.core.cache.backends.dummy.DummyCache',\n    },\n    'users': {\n        'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',\n        'LOCATION': 'users',\n    }\n}\n\n\n\n\n\nImplementation\n\n\nFor simplicity, we're going to create a single player Game in which each player has a Scenario that can advance multiple periods.\n\n\nIn your \ngame\n app module, define our model in \nmodel.py\n:\n\n\nclass\n \nModel\n(\nobject\n)\n:\n\n    \n\"\"\"\n\n\n    The model adds an operand to the previous total and returns the result.\n\n\n    \"\"\"\n\n\n    \ndef\n \nstep\n(\nself\n,\n \noperand\n,\n \nprev_total\n=\n0.0\n)\n:\n\n        \n\"\"\"\n\n\n        Parameters:\n\n\n            operand - current period's decision\n\n\n            prev_total - the calculated total from the previous period\n\n\n        Returns new total\n\n\n        \"\"\"\n\n        \nreturn\n \noperand\n \n+\n \nprev_total\n\n\n\n\n\n\nIn your \ngame\n app module, add a unit test directory \ntests\n and a model unit test \ntests/test_model.py\n:\n\n\nimport\n \npytest\n\n\nfrom\n \ntest_plus.test\n \nimport\n \nTestCase\n\n\n\nfrom\n \ngame.model\n \nimport\n \nModel\n\n\n\n\nclass\n \nModelTestCase\n(\nTestCase\n):\n\n    \ndef\n \nsetUp\n(\nself\n):\n\n        \nself\n.\nm\n \n=\n \nModel\n()\n\n\n    \ndef\n \ntest_create\n(\nself\n):\n\n        \nm\n \n=\n \nModel\n()\n\n        \nself\n.\nassertNotEqual\n(\nm\n,\n \nNone\n)\n\n\n    \ndef\n \ntest_first_step\n(\nself\n):\n\n        \nm\n \n=\n \nModel\n()\n\n        \ntotal\n \n=\n \nm\n.\nstep\n(\n5\n)\n\n        \nself\n.\nassertEquals\n(\ntotal\n,\n \n5\n)\n\n\n    \ndef\n \ntest_increase_step\n(\nself\n):\n\n        \nm\n \n=\n \nModel\n()\n\n        \ntotal\n \n=\n \nm\n.\nstep\n(\n5\n,\n \n3\n)\n\n        \nself\n.\nassertEquals\n(\ntotal\n,\n \n8\n)\n\n\n    \ndef\n \ntest_decrease_step\n(\nself\n):\n\n        \nm\n \n=\n \nModel\n()\n\n        \ntotal\n \n=\n \nm\n.\nstep\n(\n5\n,\n \n-\n2.5\n)\n\n        \nself\n.\nassertEquals\n(\ntotal\n,\n \n2.5\n)\n\n\n\n\n\n\nRun your unit test:\n\n\n$ \nexport\n \nDJANGO_SETTINGS_MODULE\n=\ncalc_model.settings\n$ py.test\n\n\n\n\n\nCreate a management command that will create your game and initialize it with one run, a leader and 2 players.\n\n\nCreate a 'management' folder in the \ngame\n folder and add an empty \n__init__.py\n file.\n\n\nCreate a 'commands' folder in the \nmanagement\n folder  and add an empty \n__init__.py\n file.\n\n\nFinally, create a \ncreate_default_env.py\n script in the 'commands' folder containing this code:\n\n\nimport\n \ndjclick\n \nas\n \nclick\n\n\n\nfrom\n \nmodelservice.simpl\n \nimport\n \ngames_client\n\n\nfrom\n \nmodelservice.utils.asyncio\n \nimport\n \ncoro\n\n\n\n\ndef\n \necho\n(\ntext\n,\n \nvalue\n):\n\n    \nclick\n.\necho\n(\n\n        \nclick\n.\nstyle\n(\ntext\n,\n \nfg\n=\n'green'\n)\n \n+\n \n'{0}'\n.\nformat\n(\nvalue\n)\n\n    \n)\n\n\n\n\nasync\n \ndef\n \ndelete_default_run\n(\napi_session\n):\n\n    \n\"\"\" Delete default Run \"\"\"\n\n    \necho\n(\n'Resetting the Calc game default run...'\n,\n \n' done'\n)\n\n    \nruns\n \n=\n \nawait\n \napi_session\n.\nruns\n.\nfilter\n(\ngame_slug\n=\n'calc'\n)\n\n    \nfor\n \nrun\n \nin\n \nruns\n:\n\n        \nif\n \nrun\n.\nname\n \n==\n \n'default'\n:\n\n            \nawait\n \napi_session\n.\nruns\n.\ndelete\n(\nrun\n.\nid\n)\n\n\n\n\n@click.command\n()\n\n\n@click.option\n(\n'--reset'\n,\n \ndefault\n=\nFalse\n,\n \nis_flag\n=\nTrue\n,\n\n              \nhelp\n=\n\"Delete default game run and recreate it from scratch\"\n)\n\n\n@coro\n\n\nasync\n \ndef\n \ncommand\n(\nreset\n):\n\n    \n\"\"\"\n\n\n    Create and initialize Calc game.\n\n\n    Create a \"default\" Calc run.\n\n\n    Set the run phase to \"Play\".\n\n\n    Add 1 leader (\"leader\") to the run\n\n\n    Add 2 players (\"s1\", \"s2\") to the run.\n\n\n    Add a scenario and period 1 for each player.\n\n\n    \"\"\"\n\n\n    \nasync\n \nwith\n \ngames_client\n \nas\n \napi_session\n:\n\n\n        \n# Handle resetting the game\n\n        \nif\n \nreset\n:\n\n            \nif\n \nclick\n.\nconfirm\n(\n\n                    \n'Are you sure you want to delete the default game run and recreate from scratch?'\n):\n\n                \nawait\n \ndelete_default_run\n(\napi_session\n)\n\n\n        \n# Create a Game\n\n        \ngame\n \n=\n \nawait\n \napi_session\n.\ngames\n.\nget_or_create\n(\n\n            \nname\n=\n'Calc'\n,\n\n            \nslug\n=\n'calc'\n\n        \n)\n\n        \necho\n(\n'getting or creating game: '\n,\n \ngame\n.\nname\n)\n\n\n        \n# Create game Phases (\"Play\")\n\n        \nplay_phase\n \n=\n \nawait\n \napi_session\n.\nphases\n.\nget_or_create\n(\n\n            \ngame\n=\ngame\n.\nid\n,\n\n            \nname\n=\n'Play'\n,\n\n            \norder\n=\n1\n,\n\n        \n)\n\n        \necho\n(\n'getting or creating phase: '\n,\n \nplay_phase\n.\nname\n)\n\n\n        \n# Add run with 2 players ready to play\n\n        \nrun\n \n=\n \nawait\n \nadd_run\n(\ngame\n,\n \n'default'\n,\n \n2\n,\n \nplay_phase\n,\n \napi_session\n)\n\n\n        \necho\n(\n'Completed setting up run: id='\n,\n \nrun\n.\nid\n)\n\n\n\n\nasync\n \ndef\n \nadd_run\n(\ngame\n,\n \nrun_name\n,\n \nuser_count\n,\n \nphase\n,\n \napi_session\n):\n\n    \n# Create or get the Run\n\n    \nrun\n \n=\n \nawait\n \napi_session\n.\nruns\n.\nget_or_create\n(\n\n        \ngame\n=\ngame\n.\nid\n,\n\n        \nname\n=\nrun_name\n,\n\n    \n)\n\n    \necho\n(\n'getting or creating run: '\n,\n \nrun\n.\nname\n)\n\n\n    \n# Set run to phase\n\n    \nrun\n.\nphase\n \n=\n \nphase\n.\nid\n\n    \nawait\n \nrun\n.\nsave\n()\n\n    \necho\n(\n'setting run to phase: '\n,\n \nphase\n.\nname\n)\n\n\n    \nfac_user\n \n=\n \nawait\n \napi_session\n.\nusers\n.\nget_or_create\n(\n\n        \npassword\n=\n'leader'\n,\n\n        \nfirst_name\n=\n'CALC'\n,\n\n        \nlast_name\n=\n'Leader'\n,\n\n        \nemail\n=\n'leader@calc.edu'\n,\n\n    \n)\n\n    \necho\n(\n'getting or creating user: '\n,\n \nfac_user\n.\nemail\n)\n\n\n    \nfac_runuser\n \n=\n \nawait\n \napi_session\n.\nrunusers\n.\nget_or_create\n(\n\n        \nuser\n=\nfac_user\n.\nid\n,\n\n        \nrun\n=\nrun\n.\nid\n,\n\n        \nleader\n=\nTrue\n,\n\n    \n)\n\n    \necho\n(\n'getting or creating leader runuser for user: '\n,\n \nfac_user\n.\nemail\n)\n\n\n    \nfor\n \nn\n \nin\n \nrange\n(\n0\n,\n \nuser_count\n):\n\n        \nuser_number\n \n=\n \nn\n \n+\n \n1\n\n        \n# Add player to run\n\n        \nawait\n \nadd_player\n(\nuser_number\n,\n \nrun\n,\n \napi_session\n)\n\n\n    \nreturn\n \nrun\n\n\n\n\nasync\n \ndef\n \nadd_player\n(\nuser_number\n,\n \nrun\n,\n \napi_session\n):\n\n    \n\"\"\"Add player with name based on user_number to run with role\"\"\"\n\n\n    \nusername\n \n=\n \n's{0}'\n.\nformat\n(\nuser_number\n)\n\n    \nfirst_name\n \n=\n \n'Student{0}'\n.\nformat\n(\nuser_number\n)\n\n    \nemail\n \n=\n \n'{0}@calc.edu'\n.\nformat\n(\nusername\n)\n\n\n    \nuser\n \n=\n \nawait\n \napi_session\n.\nusers\n.\nget_or_create\n(\n\n        \npassword\n=\nusername\n,\n\n        \nfirst_name\n=\nfirst_name\n,\n\n        \nlast_name\n=\n'User'\n,\n\n        \nemail\n=\nemail\n,\n\n    \n)\n\n    \necho\n(\n'getting or creating user: '\n,\n \nuser\n.\nemail\n)\n\n\n    \nrunuser\n \n=\n \nawait\n \napi_session\n.\nrunusers\n.\nget_or_create\n(\n\n        \nuser\n=\nuser\n.\nid\n,\n\n        \nrun\n=\nrun\n.\nid\n,\n\n        \ndefaults\n=\n{\n\"role\"\n:\n \nNone\n}\n\n    \n)\n\n    \necho\n(\n'getting or creating runuser for user: '\n,\n \nuser\n.\nemail\n)\n\n\n    \nawait\n \nadd_runuser_scenario\n(\nrunuser\n,\n \napi_session\n)\n\n\n\n\nasync\n \ndef\n \nadd_runuser_scenario\n(\nrunuser\n,\n \napi_session\n):\n\n    \n\"\"\"Add a scenario named 'Scenario 1' to the runuser\"\"\"\n\n\n    \nscenario\n \n=\n \nawait\n \napi_session\n.\nscenarios\n.\nget_or_create\n(\n\n        \nrunuser\n=\nrunuser\n.\nid\n,\n\n        \nname\n=\n'Scenario 1'\n,\n\n    \n)\n\n    \nclick\n.\necho\n(\n'getting or creating runuser {} scenario: {}'\n.\nformat\n(\n\n        \nrunuser\n.\nid\n,\n\n        \nscenario\n.\nid\n))\n\n\n    \nperiod\n \n=\n \nawait\n \napi_session\n.\nperiods\n.\nget_or_create\n(\n\n        \nscenario\n=\nscenario\n.\nid\n,\n\n        \norder\n=\n1\n,\n\n    \n)\n\n    \nclick\n.\necho\n(\n'getting or creating runuser {} period 1 for scenario: {}'\n.\nformat\n(\n\n        \nrunuser\n.\nid\n,\n\n        \nscenario\n.\nid\n))\n\n\n\n\n\n\nRun your command:\n\n\n$ \nexport\n \nDJANGO_SETTINGS_MODULE\n=\ncalc_model.settings\n$ ./manage.py create_default_env\n\n\n\n\n\nEvery player's move will be a \nDecision\n saved on the current \nPeriod\n. The model will then produce a \nResult\n for the\ncurrent \nPeriod\n, and the \nScenario\n will step to the next \nPeriod\n.\n\n\nIn your \ngame\n app module, create a file called \nrunmodel.py\n.  Next, add \nsave_decision\n and \nstep_scenario\n functions to perform these steps:\n\n\nfrom\n \nmodelservice.simpl\n \nimport\n \ngames_client\n\n\nfrom\n \n.model\n \nimport\n \nModel\n\n\n\n\nasync\n \ndef\n \nsave_decision\n(\nperiod_id\n,\n \ndecision\n):\n\n    \n# add decision to period\n\n    \nasync\n \nwith\n \ngames_client\n \nas\n \napi_session\n:\n\n        \ndecision\n \n=\n \nawait\n \napi_session\n.\ndecisions\n.\nget_or_create\n(\n\n            \nperiod\n=\nperiod_id\n,\n\n            \nname\n=\n'decision'\n,\n\n            \ndata\n=\n{\n\"operand\"\n:\n \ndecision\n},\n\n            \ndefaults\n=\n{\n\"role\"\n:\n \nNone\n}\n\n        \n)\n\n        \nreturn\n \ndecision\n\n\n\n\nasync\n \ndef\n \nstep_scenario\n(\nscenario_id\n):\n\n    \n\"\"\"\n\n\n    Step the scenario's current period\n\n\n    \"\"\"\n\n    \nasync\n \nwith\n \ngames_client\n \nas\n \napi_session\n:\n\n        \nperiods\n \n=\n \nawait\n \napi_session\n.\nperiods\n.\nfilter\n(\nscenario\n=\nscenario_id\n,\n\n                                                   \nordering\n=\n'order'\n)\n\n        \nperiod_count\n \n=\n \nlen\n(\nperiods\n)\n\n        \nperiod\n \n=\n \nperiods\n[\nperiod_count\n \n-\n \n1\n]\n\n\n        \noperand\n \n=\n \n0.0\n\n        \nperiod_decisions\n \n=\n \nawait\n \napi_session\n.\ndecisions\n.\nfilter\n(\nperiod\n=\nperiod\n.\nid\n)\n\n        \nif\n \nlen\n(\nperiod_decisions\n)\n \n>\n \n0\n:\n\n            \noperand\n \n=\n \nfloat\n(\nperiod_decisions\n[\n0\n]\n.\ndata\n[\n\"operand\"\n])\n\n\n        \nprev_total\n \n=\n \n0.0\n\n        \nif\n \nperiod_count\n \n>\n \n1\n:\n\n            \nprev_period\n \n=\n \nperiods\n[\nperiod_count\n \n-\n \n2\n]\n\n            \nprev_period_results\n \n=\n \\\n                \nawait\n \napi_session\n.\nresults\n.\nfilter\n(\nperiod\n=\nprev_period\n.\nid\n)\n\n            \nif\n \nlen\n(\nprev_period_results\n)\n \n>\n \n0\n:\n\n                \nprev_total\n \n=\n \nfloat\n(\nprev_period_results\n[\n0\n]\n.\ndata\n[\n\"total\"\n])\n\n\n        \n# step model\n\n        \nmodel\n \n=\n \nModel\n()\n\n        \ntotal\n \n=\n \nmodel\n.\nstep\n(\noperand\n,\n \nprev_total\n)\n\n        \ndata\n \n=\n \n{\n\"total\"\n:\n \ntotal\n}\n\n\n        \nresult\n \n=\n \nawait\n \napi_session\n.\nresults\n.\nget_or_create\n(\n\n            \nperiod\n=\nperiod\n.\nid\n,\n\n            \nname\n=\n'results'\n,\n\n            \ndata\n=\ndata\n,\n\n            \ndefaults\n=\n{\n\"role\"\n:\n \nNone\n}\n\n        \n)\n\n\n        \n# prepare for next step by adding a new period\n\n        \nnext_period_order\n \n=\n \nperiod\n.\norder\n \n+\n \n1\n\n        \nnext_period\n \n=\n \nawait\n \napi_session\n.\nperiods\n.\nget_or_create\n(\n\n            \nscenario\n=\nscenario_id\n,\n\n            \norder\n=\nnext_period_order\n,\n\n        \n)\n\n        \nawait\n \nnext_period\n.\nsave\n()\n\n\n        \nreturn\n \nnext_period\n.\nid\n\n\n\n\n\n\nIn your \ngame\n app module, create a file called \ngames.py\n with the following content:\n\n\nfrom\n \nmodelservice.games\n \nimport\n \nPeriod\n,\n \nGame\n\n\nfrom\n \nmodelservice.games\n \nimport\n \nsubscribe\n,\n \nregister\n\n\n\nfrom\n \n.runmodel\n \nimport\n \nstep_scenario\n,\n \nsave_decision\n\n\n\n\nclass\n \nCalcPeriod\n(\nPeriod\n):\n\n    \n@subscribe\n\n    \nasync\n \ndef\n \nsubmit_decision\n(\nself\n,\n \noperand\n,\n \n**\nkwargs\n):\n\n        \n\"\"\"\n\n\n        Receives the operand played and stores as a ``Decision`` then\n\n\n        steps the model saving the ``Result``. A new ``Period`` is added to\n\n\n        scenario in preparation for the next decision.\n\n\n        \"\"\"\n\n        \n# Call will prefix the ROOT_TOPIC\n\n        \n# \"world.simpl.sims.calc.model.period.1.submit_decision\"\n\n\n        \nfor\n \nk\n \nin\n \nkwargs\n:\n\n            \nself\n.\nsession\n.\nlog\n.\ninfo\n(\n\"submit_decision: Key: {}\"\n.\nformat\n(\nk\n))\n\n\n        \nawait\n \nsave_decision\n(\nself\n.\npk\n,\n \noperand\n)\n\n        \nself\n.\nsession\n.\nlog\n.\ninfo\n(\n\"submit_decision: saved decision\"\n)\n\n\n        \nawait\n \nstep_scenario\n(\nself\n.\nscenario\n.\npk\n)\n\n        \nself\n.\nsession\n.\nlog\n.\ninfo\n(\n\"submit_decision: stepped scenario\"\n)\n\n\n\n\nGame\n.\nregister\n(\n'calc'\n,\n \n[\n\n    \nCalcPeriod\n,\n\n\n])\n\n\n\n\n\n\nNOTE:\n if you\nwant to use a filename other than \ngames.py\n you must ensure the file is imported\nsomewhere, usually in a \n__init__.py\n somewhere for the \n@game\n decorator to find\nand register your game into the system.\n\n\nYou can start your model service by running:\n\n\n$ \nexport\n \nDJANGO_SETTINGS_MODULE\n=\ncalc_model.settings\n$ ./manage.py run_modelservice\n\n\n\n\n\nBy default the service will bind to \n0.0.0.0:8080\n.\n\n\nThis concludes the tutorial on Model Service. A completed example implementation is available at \ngithub.com:simplworld/simpl-calc-model.git\n\nthat uses the game slug \nsimpl-calc\n.\n\n\nYou can now head over to the \nFrontend tutorial\n.",
            "title": "Build the Single Player Model Service"
        },
        {
            "location": "/tutorials/single-player/modelservice/#building-the-model-service-implementation",
            "text": "",
            "title": "Building the Model Service implementation"
        },
        {
            "location": "/tutorials/single-player/modelservice/#prerequisites",
            "text": "Note  This tutorial assumes you have  Games API service  running (http://localhost:8100/) on a Vagrant box you have provisioned.  Please open up an additional terminal window before continuing.",
            "title": "Prerequisites"
        },
        {
            "location": "/tutorials/single-player/modelservice/#installation",
            "text": "First, log into Vagrant and create a new virtualenv called 'calc-model':  $ vagrant ssh\n$ mkvirtualenv calc-model  Install Django  $ pip install  Django == 1 .11.11  Change to the projects folder:  $  cd  projects  Create a Django project folder and rename it to serve as a git repository  $ django-admin startproject calc_model\n$ mv calc_model calc-model  Change to the project folder:  $  cd  calc-model\n$ add2virtualenv .  Create a  requirements.txt  file that installs the simpl-modelservice and unit testing apps:  https://github.com:simplworld/simpl-modelservice/repository/archive.zip\n\n# tests\npytest==3.1.3\npytest-cov==2.5.1\npytest-django==3.1.2\ndjango-test-plus==1.0.22  Install these requirements along with their dependencies:  $  PIP_PROCESS_DEPENDENCY_LINKS = 1  pip install -r requirements.txt  Please note, if  DJANGO_SETTINGS_MODULE  is leftover from a previous session, you may need to unset it:  $  unset  DJANGO_SETTINGS_MODULE  Create a django app that will contain your game logic:  $ ./manage.py startapp game  Add the following to your  INSTALLED_APPS  in  calc_model/settings.py :  INSTALLED_APPS   +=   [ \n     ... \n\n     'modelservice' , \n     'rest_framework' , \n\n     'game' ,  ]  CALLBACK_URL   =   os . environ . get ( 'CALLBACK_URL' ,   'http://{hostname}:{port}/callback' )  SIMPL_GAMES_URL   =   os . environ . get ( 'SIMPL_GAMES_URL' ,   'http://localhost:8100/apis' )  SIMPL_GAMES_AUTH   =   ( 'simpl@simpl.world' ,   'simpl' )  ROOT_TOPIC   =   'world.simpl.sims.calc'   It's highly recommended that you set a  'users'  cache. Since the modelservice will run single-threaded, you can take advantage of the  locmem  backend:  CACHES = {\n    'default': {\n        'BACKEND': 'django.core.cache.backends.dummy.DummyCache',\n    },\n    'users': {\n        'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',\n        'LOCATION': 'users',\n    }\n}",
            "title": "Installation"
        },
        {
            "location": "/tutorials/single-player/modelservice/#implementation",
            "text": "For simplicity, we're going to create a single player Game in which each player has a Scenario that can advance multiple periods.  In your  game  app module, define our model in  model.py :  class   Model ( object ) : \n     \"\"\"      The model adds an operand to the previous total and returns the result.      \"\"\" \n\n     def   step ( self ,   operand ,   prev_total = 0.0 ) : \n         \"\"\"          Parameters:              operand - current period's decision              prev_total - the calculated total from the previous period          Returns new total          \"\"\" \n         return   operand   +   prev_total   In your  game  app module, add a unit test directory  tests  and a model unit test  tests/test_model.py :  import   pytest  from   test_plus.test   import   TestCase  from   game.model   import   Model  class   ModelTestCase ( TestCase ): \n     def   setUp ( self ): \n         self . m   =   Model () \n\n     def   test_create ( self ): \n         m   =   Model () \n         self . assertNotEqual ( m ,   None ) \n\n     def   test_first_step ( self ): \n         m   =   Model () \n         total   =   m . step ( 5 ) \n         self . assertEquals ( total ,   5 ) \n\n     def   test_increase_step ( self ): \n         m   =   Model () \n         total   =   m . step ( 5 ,   3 ) \n         self . assertEquals ( total ,   8 ) \n\n     def   test_decrease_step ( self ): \n         m   =   Model () \n         total   =   m . step ( 5 ,   - 2.5 ) \n         self . assertEquals ( total ,   2.5 )   Run your unit test:  $  export   DJANGO_SETTINGS_MODULE = calc_model.settings\n$ py.test  Create a management command that will create your game and initialize it with one run, a leader and 2 players.  Create a 'management' folder in the  game  folder and add an empty  __init__.py  file.  Create a 'commands' folder in the  management  folder  and add an empty  __init__.py  file.  Finally, create a  create_default_env.py  script in the 'commands' folder containing this code:  import   djclick   as   click  from   modelservice.simpl   import   games_client  from   modelservice.utils.asyncio   import   coro  def   echo ( text ,   value ): \n     click . echo ( \n         click . style ( text ,   fg = 'green' )   +   '{0}' . format ( value ) \n     )  async   def   delete_default_run ( api_session ): \n     \"\"\" Delete default Run \"\"\" \n     echo ( 'Resetting the Calc game default run...' ,   ' done' ) \n     runs   =   await   api_session . runs . filter ( game_slug = 'calc' ) \n     for   run   in   runs : \n         if   run . name   ==   'default' : \n             await   api_session . runs . delete ( run . id )  @click.command ()  @click.option ( '--reset' ,   default = False ,   is_flag = True , \n               help = \"Delete default game run and recreate it from scratch\" )  @coro  async   def   command ( reset ): \n     \"\"\"      Create and initialize Calc game.      Create a \"default\" Calc run.      Set the run phase to \"Play\".      Add 1 leader (\"leader\") to the run      Add 2 players (\"s1\", \"s2\") to the run.      Add a scenario and period 1 for each player.      \"\"\" \n\n     async   with   games_client   as   api_session : \n\n         # Handle resetting the game \n         if   reset : \n             if   click . confirm ( \n                     'Are you sure you want to delete the default game run and recreate from scratch?' ): \n                 await   delete_default_run ( api_session ) \n\n         # Create a Game \n         game   =   await   api_session . games . get_or_create ( \n             name = 'Calc' , \n             slug = 'calc' \n         ) \n         echo ( 'getting or creating game: ' ,   game . name ) \n\n         # Create game Phases (\"Play\") \n         play_phase   =   await   api_session . phases . get_or_create ( \n             game = game . id , \n             name = 'Play' , \n             order = 1 , \n         ) \n         echo ( 'getting or creating phase: ' ,   play_phase . name ) \n\n         # Add run with 2 players ready to play \n         run   =   await   add_run ( game ,   'default' ,   2 ,   play_phase ,   api_session ) \n\n         echo ( 'Completed setting up run: id=' ,   run . id )  async   def   add_run ( game ,   run_name ,   user_count ,   phase ,   api_session ): \n     # Create or get the Run \n     run   =   await   api_session . runs . get_or_create ( \n         game = game . id , \n         name = run_name , \n     ) \n     echo ( 'getting or creating run: ' ,   run . name ) \n\n     # Set run to phase \n     run . phase   =   phase . id \n     await   run . save () \n     echo ( 'setting run to phase: ' ,   phase . name ) \n\n     fac_user   =   await   api_session . users . get_or_create ( \n         password = 'leader' , \n         first_name = 'CALC' , \n         last_name = 'Leader' , \n         email = 'leader@calc.edu' , \n     ) \n     echo ( 'getting or creating user: ' ,   fac_user . email ) \n\n     fac_runuser   =   await   api_session . runusers . get_or_create ( \n         user = fac_user . id , \n         run = run . id , \n         leader = True , \n     ) \n     echo ( 'getting or creating leader runuser for user: ' ,   fac_user . email ) \n\n     for   n   in   range ( 0 ,   user_count ): \n         user_number   =   n   +   1 \n         # Add player to run \n         await   add_player ( user_number ,   run ,   api_session ) \n\n     return   run  async   def   add_player ( user_number ,   run ,   api_session ): \n     \"\"\"Add player with name based on user_number to run with role\"\"\" \n\n     username   =   's{0}' . format ( user_number ) \n     first_name   =   'Student{0}' . format ( user_number ) \n     email   =   '{0}@calc.edu' . format ( username ) \n\n     user   =   await   api_session . users . get_or_create ( \n         password = username , \n         first_name = first_name , \n         last_name = 'User' , \n         email = email , \n     ) \n     echo ( 'getting or creating user: ' ,   user . email ) \n\n     runuser   =   await   api_session . runusers . get_or_create ( \n         user = user . id , \n         run = run . id , \n         defaults = { \"role\" :   None } \n     ) \n     echo ( 'getting or creating runuser for user: ' ,   user . email ) \n\n     await   add_runuser_scenario ( runuser ,   api_session )  async   def   add_runuser_scenario ( runuser ,   api_session ): \n     \"\"\"Add a scenario named 'Scenario 1' to the runuser\"\"\" \n\n     scenario   =   await   api_session . scenarios . get_or_create ( \n         runuser = runuser . id , \n         name = 'Scenario 1' , \n     ) \n     click . echo ( 'getting or creating runuser {} scenario: {}' . format ( \n         runuser . id , \n         scenario . id )) \n\n     period   =   await   api_session . periods . get_or_create ( \n         scenario = scenario . id , \n         order = 1 , \n     ) \n     click . echo ( 'getting or creating runuser {} period 1 for scenario: {}' . format ( \n         runuser . id , \n         scenario . id ))   Run your command:  $  export   DJANGO_SETTINGS_MODULE = calc_model.settings\n$ ./manage.py create_default_env  Every player's move will be a  Decision  saved on the current  Period . The model will then produce a  Result  for the\ncurrent  Period , and the  Scenario  will step to the next  Period .  In your  game  app module, create a file called  runmodel.py .  Next, add  save_decision  and  step_scenario  functions to perform these steps:  from   modelservice.simpl   import   games_client  from   .model   import   Model  async   def   save_decision ( period_id ,   decision ): \n     # add decision to period \n     async   with   games_client   as   api_session : \n         decision   =   await   api_session . decisions . get_or_create ( \n             period = period_id , \n             name = 'decision' , \n             data = { \"operand\" :   decision }, \n             defaults = { \"role\" :   None } \n         ) \n         return   decision  async   def   step_scenario ( scenario_id ): \n     \"\"\"      Step the scenario's current period      \"\"\" \n     async   with   games_client   as   api_session : \n         periods   =   await   api_session . periods . filter ( scenario = scenario_id , \n                                                    ordering = 'order' ) \n         period_count   =   len ( periods ) \n         period   =   periods [ period_count   -   1 ] \n\n         operand   =   0.0 \n         period_decisions   =   await   api_session . decisions . filter ( period = period . id ) \n         if   len ( period_decisions )   >   0 : \n             operand   =   float ( period_decisions [ 0 ] . data [ \"operand\" ]) \n\n         prev_total   =   0.0 \n         if   period_count   >   1 : \n             prev_period   =   periods [ period_count   -   2 ] \n             prev_period_results   =  \\\n                 await   api_session . results . filter ( period = prev_period . id ) \n             if   len ( prev_period_results )   >   0 : \n                 prev_total   =   float ( prev_period_results [ 0 ] . data [ \"total\" ]) \n\n         # step model \n         model   =   Model () \n         total   =   model . step ( operand ,   prev_total ) \n         data   =   { \"total\" :   total } \n\n         result   =   await   api_session . results . get_or_create ( \n             period = period . id , \n             name = 'results' , \n             data = data , \n             defaults = { \"role\" :   None } \n         ) \n\n         # prepare for next step by adding a new period \n         next_period_order   =   period . order   +   1 \n         next_period   =   await   api_session . periods . get_or_create ( \n             scenario = scenario_id , \n             order = next_period_order , \n         ) \n         await   next_period . save () \n\n         return   next_period . id   In your  game  app module, create a file called  games.py  with the following content:  from   modelservice.games   import   Period ,   Game  from   modelservice.games   import   subscribe ,   register  from   .runmodel   import   step_scenario ,   save_decision  class   CalcPeriod ( Period ): \n     @subscribe \n     async   def   submit_decision ( self ,   operand ,   ** kwargs ): \n         \"\"\"          Receives the operand played and stores as a ``Decision`` then          steps the model saving the ``Result``. A new ``Period`` is added to          scenario in preparation for the next decision.          \"\"\" \n         # Call will prefix the ROOT_TOPIC \n         # \"world.simpl.sims.calc.model.period.1.submit_decision\" \n\n         for   k   in   kwargs : \n             self . session . log . info ( \"submit_decision: Key: {}\" . format ( k )) \n\n         await   save_decision ( self . pk ,   operand ) \n         self . session . log . info ( \"submit_decision: saved decision\" ) \n\n         await   step_scenario ( self . scenario . pk ) \n         self . session . log . info ( \"submit_decision: stepped scenario\" )  Game . register ( 'calc' ,   [ \n     CalcPeriod ,  ])   NOTE:  if you\nwant to use a filename other than  games.py  you must ensure the file is imported\nsomewhere, usually in a  __init__.py  somewhere for the  @game  decorator to find\nand register your game into the system.  You can start your model service by running:  $  export   DJANGO_SETTINGS_MODULE = calc_model.settings\n$ ./manage.py run_modelservice  By default the service will bind to  0.0.0.0:8080 .  This concludes the tutorial on Model Service. A completed example implementation is available at  github.com:simplworld/simpl-calc-model.git \nthat uses the game slug  simpl-calc .  You can now head over to the  Frontend tutorial .",
            "title": "Implementation"
        },
        {
            "location": "/tutorials/single-player/frontend/",
            "text": "Building the Frontend UI\n\n\nPrerequisites\n\n\nThis tutorial assumes you already the following software installed:\n\n\n\n\nNode >= 5.7.0\n\n\nNPM >= 3.6.0\n\n\n\n\n\n\nNote\n\n\nThis tutorial assumes you still have both the \nGames API service\n (http://localhost:8100/) and the \nModel service\n (http://localhost:8080/) running.  Please open up an additional terminal window and SSH into the Vagrant box before continuing.\n\n\n\n\nInstallation\n\n\nFirst, create a new virtualenv called 'calc-ui':\n\n\n$ mkvirtualenv calc-ui\n\n\n\n\n\nThen, install the \ncookiecutter\n Python package:\n\n\n$ pip install cookiecutter\n\n\n\n\n\nChange to the \n/vagrant/projects\n folder:\n\n\n$ \ncd\n projects\n\n\n\n\n\nUse \ncookiecutter\n to create the boilerplate for your app\n\n\n$ cookiecutter https://github.com:simplworld/simpl-ui-cookiecutter.git\n\n\n\n\n\nMake sure the value for \ngame_slug\n is the same slug you used in the \nmodelservice tutorial\n. If you are using defaults from the tutorial,\nthen the slug should be \ncalc\n. For all other values you can use the default for the project, or choose your own.\n\n\nFor example,\n\n\nproject_name\n \n[\nSimulation\n \nUI\n]\n:\n \nCalc\n \nUI\n\n\nrepo_slug\n \n[\ncalc\n-\nui\n]\n:\n\n\nproject_slug\n \n[\ncalc_ui\n]\n:\n\n\ngame_slug\n \n[\ncalc\n-\nui\n]\n:\n \ncalc\n\n\nmodelservice_slug\n \n[\ncalc\n-\nmodel\n]\n:\n\n\ntopic_root\n \n[\nworld\n.\nsimpl\n]\n:\n\n\napp_slug\n \n[\nfrontend\n]\n:\n\n\nversion\n \n[\n0.1.0\n]\n:\n\n\n\n\n\n\nAfter the project layout is created, \ncd\n into your repo directory and install the requirements:\n\n\n$ pip install -r requirements.txt\n\n\n\n\n\nOutside of Vagrant, \ncd\n into your your repo directory, install the JavaScript node modules and run gulp to keep the web server's javascript updated as you work on the frontend:\n\n\n$ npm install\n$ gulp\n\n\n\n\n\nTo aid development, you can install the following Chrome DevTools Extensions:\n\n\n\n\nRedux DevTools Extension\n\n\nReact Developer Tools\n\n\n\n\nIt is also recommended to configure your editor to integrate with ESLint:\n\n\n\n\nPyCharm\n\n\nSublimeText2\n\n\n\n\nConfiguration\n\n\nJust like most Websites, the frontend service will need a place where it can store information about sessions and their users. The users' specific information will be fetched from the \nSimple Games API\n and kept in sync automatically.\n\n\n\n\nNote\n\n\nFor the purposes of this tutorial we're going to use SQLite, but this can be changed to match whatever database backend you prefer. In a production environment, you'll likely want to switch to something like PostgreSQL.\n\n\n\n\nFirst, let's create the necessary local tables:\n\n\n$ ./manage.py migrate\n\n\n\n\n\nThen, start your frontend service with:\n\n\n$ ./manage.py runserver \n0\n.0.0.0:8000\n\n\n\n\n\nIn Chrome, head to \nhttp://localhost:8000/\n and login as 's1@calc.edu' with password 's1'.\nOnce you are logged in, you should see the 'Hello Player' message of the skeleton app.\n\n\n\n\nOpen Chrome's DevTools, and select the 'Redux' tab. You will see a list of actions, and the\ncurrent \nstate\n of the store. Note that the state has a property named \nsimpl\n. Expand the \nsimpl\n property\nto see all the scope properties associated with the current user.\n\n\n\n\nThis properties will be updated as the model service adds, removes or updates scopes.\nYou will connect your components to the properties and they will update accordingly.\n\n\nNext, logout by going to \nlocalhost:8000/logout/\n in your browser. Then login as leader@calc.edu with password 'leader'.\nOnce you are logged in, you should see the 'Hello Leader' message of the skeleton app. If you look at the \nsimpl\n\nstate properties, they look similar to those of players. Only information about the current user has been loaded.\n\n\n\n\nIn a multi-player simulation, players are assigned to a world with other players.\nThe cookiecutter template assumes you are implementing a multi-player simulation in which players\nsee only their own and their world's data. By default, leaders can see the worlds and users in their subscribed runs,\nbut not the scenarios of other users. Consequently, the template \njs/modules/Root.js\n sets the simpl decorator's loadAllScenarios argument false to block access to scenarios of other users.\n\n\nWe want Calc leaders to have access to all information on all players in their runs. Since Calc players are not associated with\na world, we need to modify the template \njs/modules/Root.js\n code to load all player scenarios for leaders.\n\n\nIn your \njs/modules/Root.js\n:\n\n\nexport default simpl({\n  authid: AUTHID,\n  password: 'nopassword',\n  url: `\n${\nMODEL_SERVICE\n}\n`,\n  progressComponent: Progress,\n  root_topic: ROOT_TOPIC,\n  topics: () => topics,\n  loadAllScenarios: false\n})(RootContainer);\n\n\n\n\n\nchange the simpl decorator's loadAllScenarios argument to LEADER:\n\n\nexport default simpl({\n  authid: AUTHID,\n  password: 'nopassword',\n  url: `\n${\nMODEL_SERVICE\n}\n`,\n  progressComponent: Progress,\n  root_topic: ROOT_TOPIC,\n  topics: () => topics,\n  loadAllScenarios: LEADER\n})(RootContainer);\n\n\n\n\n\nRefresh your Chrome browser page and you'll see all the run's runusers have been loaded into the \nsimpl\n state.\n\n\n\n\nThese properties will be updated as the model service adds, removes or updates scopes. You will connect your components to the properties and they will update accordingly.\n\n\nImplementation\n\n\nTo implement your UI, you will write Smart Components and Presentational Components.\n\n\nThe Presentational Components will provide the necessary markup to render UI elements, while the Smart Components will wrap them providing the necessary data.\n\n\nFirst, create an action in \njs/actions/Actions.js\n for submitting decisions to the \nsubmit_decision\n topic defined by calc-model \ngame/games.py\n.\n\n\nimport\n \n{\ncreateAction\n}\n \nfrom\n \n'redux-actions'\n;\n\n\n\nimport\n \nAutobahnReact\n \nfrom\n \n'simpl/lib/autobahn'\n;\n\n\n\n//\n \nsubmit\n \nplayer\n \ndecision\n \nand\n \nadvance\n \nto\n \nnext\n \nperiod\n\n\nexport\n \nconst\n \nsubmitDecision\n \n=\n\n    \ncreateAction\n(\n'SUBMIT_DECISION'\n,\n \n(\nperiod\n,\n \noperand\n,\n \n...\nargs\n)\n \n=>\n\n        \nAutobahnReact\n.\npublish\n(\n`model:model.period.${period.id}.submit_decision`\n,\n \n[\noperand\n])\n\n    \n);\n\n\n\n\n\n\nNote the action publishes to the topic because the calc-model \ngame/games.py\nsubmit_decision` endpoint subscribes to the topic.\n\n\nCreate a presentation component \njs/components/DecisionForm.js\n for entering player decisions:\n\n\nimport\n \nReact\n \nfrom\n \n'react'\n;\n\n\nimport\n \nPropTypes\n \nfrom\n \n'prop-types'\n;\n\n\n\nimport\n \n{\nButton\n}\n \nfrom\n \n'react-bootstrap'\n;\n\n\n\nimport\n \n{\nField\n,\n \nreduxForm\n}\n \nfrom\n \n'redux-form'\n;\n\n\n\nclass\n \nDecisionForm\n \nextends\n \nReact\n.\nComponent\n \n{\n\n\n  \nconstructor\n(\nprops\n)\n \n{\n\n    \nsuper\n(\nprops\n);\n\n    \nthis\n.\nsubmitForm\n \n=\n \nthis\n.\nsubmitForm\n.\nbind\n(\nthis\n);\n\n  \n}\n\n\n  \nsubmitForm\n(\nvalues\n)\n \n{\n\n    \nthis\n.\nprops\n.\nsubmitDecision\n(\nvalues\n);\n\n  \n}\n\n\n  \nrender\n()\n \n{\n\n    \nconst\n \n{\nerror\n,\n \nhandleSubmit\n,\n \nsubmitting\n,\n \ninvalid\n}\n \n=\n \nthis\n.\nprops\n;\n\n    \nreturn\n \n(\n\n      \n<\ndiv\n \nclassName\n=\n\"content-wrapper\"\n>\n\n        \n<\nform\n \nid\n=\n\"testScenarioForm\"\n \nonSubmit\n=\n{\nhandleSubmit\n(\nthis\n.\nsubmitForm\n)}\n>\n\n\n          \n<\ndiv\n \nclassName\n=\n\"form-group\"\n>\n\n            \n<\nlabel\n>\nEnter\n \na\n \nnumber\n:\n</\nlabel\n>\n\n            \n<\nField\n\n              \ncomponent\n=\n\"input\"\n\n              \ntype\n=\n\"number\"\n\n              \nname\n=\n\"operand\"\n\n              \nid\n=\n\"operand\"\n\n              \nrequired\n=\n\"true\"\n\n              \nstep\n=\n\"any\"\n\n            \n/>\n\n          \n</\ndiv\n>\n\n\n          \n<\ndiv\n>\n\n            \n<\nButton\n\n              \ntype\n=\n\"submit\"\n\n              \nbsClass\n=\n\"btn btn-mr btn-labeled btn-success\"\n\n              \nbsStyle\n=\n\"success\"\n\n              \ndisabled\n=\n{\ninvalid\n \n||\n \nsubmitting\n}\n\n            \n>\nAdd\n \nto\n \nTotal\n</\nButton\n>\n\n          \n</\ndiv\n>\n\n\n          \n<\ndiv\n>\n\n            \n{\nerror\n \n&&\n \n<\ndiv\n><\np\n>\n{\nerror\n}\n</\np\n></\ndiv\n>\n}\n\n          \n</\ndiv\n>\n\n\n        \n</\nform\n>\n\n      \n</\ndiv\n \n>\n\n    \n);\n\n  \n}\n\n\n}\n\n\n\nDecisionForm\n.\npropTypes\n \n=\n \n{\n\n  \nrunuser\n:\n \nPropTypes\n.\nobject\n.\nisRequired\n,\n\n  \ninitialValues\n:\n \nPropTypes\n.\nobject\n.\nisRequired\n,\n\n\n  \n//\n \nredux\n-\nform\n \nprops\n\n  \nhandleSubmit\n:\n \nPropTypes\n.\nfunc\n,\n\n  \ninvalid\n:\n \nPropTypes\n.\nbool\n,\n\n  \nsubmitting\n:\n \nPropTypes\n.\nbool\n,\n\n  \nerror\n:\n \nPropTypes\n.\nstring\n,\n\n\n  \n//\n \ndispatch\n \nactions\n\n  \nsubmitDecision\n:\n \nPropTypes\n.\nfunc\n.\nisRequired\n\n\n};\n\n\n\nexport\n \ndefault\n \nreduxForm\n({\n\n  \nform\n:\n \n'decisionForm'\n\n\n})(\nDecisionForm\n);\n\n\n\n\n\n\nwrap it in a smart component \njs/containers/DecisionFormContainer.js\n\n\nimport\n \n{\nconnect\n}\n \nfrom\n \n'react-redux'\n;\n\n\nimport\n \n{\nwithRouter\n}\n \nfrom\n \n'react-router'\n;\n\n\n\nimport\n \nDecisionForm\n \nfrom\n \n'../components/DecisionForm'\n;\n\n\n\nimport\n \n{\nsubmitDecision\n}\n \nfrom\n \n'../actions/Actions'\n;\n\n\n\nfunction\n \nmapStateToProps\n(\nstate\n,\n \nownProps\n)\n \n{\n\n  \nconst\n \ninitialValues\n \n=\n \n{\n\n    \n'operand'\n:\n \n0\n\n  \n};\n\n  \nreturn\n \n{\n\n    \nrunuser\n:\n \nstate\n.\nsimpl\n.\ncurrent_runuser\n,\n\n    \ninitialValues\n\n  \n};\n\n\n}\n\n\n\nfunction\n \nmapDispatchToProps\n(\ndispatch\n,\n \nownProps\n)\n \n{\n\n  \nreturn\n \n{\n\n    \nsubmitDecision\n(\nvalues\n)\n \n{\n\n      \n//\n \nsubmit\n \nplayer\n's decision\n\n      \nconst\n \noperand\n \n=\n \nvalues\n.\noperand\n;\n\n      \ndispatch\n(\nsubmitDecision\n(\nownProps\n.\ncurrentPeriod\n,\n \noperand\n))\n\n    \n}\n\n  \n};\n\n\n}\n\n\n\nconst\n \nDecisionFormContainer\n \n=\n \nconnect\n(\n\n  \nmapStateToProps\n,\n\n  \nmapDispatchToProps\n\n\n)(\nDecisionForm\n);\n\n\n\nexport\n \ndefault\n \nwithRouter\n(\nDecisionFormContainer\n);\n\n\n\n\n\n\nIn your \njs/modules/PlayerHome.js\n, replace the original contents with:\n\n\nimport\n \nReact\n \nfrom\n \n'react'\n;\n\n\nimport\n \nPropTypes\n \nfrom\n \n'prop-types'\n;\n\n\n\nimport\n \n{\nconnect\n}\n \nfrom\n \n'react-redux'\n;\n\n\n\nimport\n \nDecisionFormContainer\n \nfrom\n \n'../containers/DecisionFormContainer'\n\n\n\nclass\n \nPlayerHome\n \nextends\n \nReact\n.\nComponent\n \n{\n\n  \nrender\n()\n \n{\n\n    \nreturn\n \n(\n\n      \n<\ndiv\n>\n\n        \n<\nh1\n>\nHello\n \nPlayer\n:\n \n{\nthis\n.\nprops\n.\nrunuser\n.\nemail\n}\n</\nh1\n>\n\n        \n<\np\n>\nCurrent\n \ntotal\n:\n \n{\nthis\n.\nprops\n.\ntotal\n}\n</\np\n>\n\n        \n<\nDecisionFormContainer\n \ncurrentPeriod\n=\n{\nthis\n.\nprops\n.\ncurrentPeriod\n}\n/>\n\n        \n<\nbr\n/>\n\n        \n<\na\n \nhref\n=\n\"/logout/\"\n \nclassName\n=\n\"btn btn-success btn-lg\"\n>\nLogout\n</\na\n>\n\n      \n</\ndiv\n>\n\n    \n);\n\n  \n}\n\n\n}\n\n\n\nPlayerHome\n.\npropTypes\n \n=\n \n{\n\n  \nrunuser\n:\n \nPropTypes\n.\nobject\n.\nisRequired\n,\n\n  \ntotal\n:\n \nPropTypes\n.\nnumber\n,\n\n  \ncurrentPeriod\n:\n \nPropTypes\n.\nobject\n.\nisRequired\n,\n\n\n};\n\n\n\nfunction\n \nmapStateToProps\n(\nstate\n)\n \n{\n\n  \nconst\n \nrunuser\n \n=\n \nstate\n.\nsimpl\n.\ncurrent_runuser\n;\n\n\n  \nconst\n \nscenario\n \n=\n \nstate\n.\nsimpl\n.\nscenario\n.\nfind\n(\n\n    \n(\ns\n)\n \n=>\n \nrunuser\n.\nid\n \n===\n \ns\n.\nrunuser\n\n  \n);\n\n\n  \nconst\n \nunsortedPeriods\n \n=\n \nstate\n.\nsimpl\n.\nperiod\n.\nfilter\n(\n\n    \n(\np\n)\n \n=>\n \nscenario\n.\nid\n \n===\n \np\n.\nscenario\n\n  \n);\n\n  \nconst\n \nperiods\n \n=\n \n_\n.\nsortBy\n(\nunsortedPeriods\n,\n \n(\np\n)\n \n=>\n \np\n.\norder\n);\n\n  \nconst\n \nperiodOrder\n \n=\n \n_\n.\nlast\n(\nperiods\n)\n.\norder\n;\n\n\n  \nlet\n \ntotal\n \n=\n \n0\n;\n\n  \nif\n \n(\nperiodOrder\n \n>\n \n1\n)\n \n{\n \n//\n \npull\n \ntotal\n \nfrom\n \nlast\n \nresult\n\n    \nconst\n \nlastPeriod\n \n=\n \nperiods\n[\nperiodOrder\n \n-\n \n2\n];\n\n    \nconst\n \nlastResult\n \n=\n \nstate\n.\nsimpl\n.\nresult\n.\nfind\n(\n\n      \n(\ns\n)\n \n=>\n \nlastPeriod\n.\nid\n \n===\n \ns\n.\nperiod\n\n    \n);\n\n    \ntotal\n \n=\n \nlastResult\n.\ndata\n.\ntotal\n;\n\n  \n}\n\n\n  \nconst\n \ncurrentPeriod\n \n=\n \nperiods\n[\nperiodOrder\n \n-\n \n1\n];\n\n\n  \nreturn\n \n{\n\n    \nrunuser\n,\n\n    \ntotal\n,\n\n    \ncurrentPeriod\n\n  \n};\n\n\n}\n\n\n\nconst\n \nmodule\n \n=\n \nconnect\n(\n\n  \nmapStateToProps\n,\n\n  \nnull\n\n\n)(\nPlayerHome\n);\n\n\n\nexport\n \ndefault\n \nmodule\n;\n\n\n\n\n\n\nNow when a player logs in, they see a form for entering decisions and a logout link:\n\n\n\n\nAs the player submits decisions, the redux state automatically updates with new periods, decisions and results:\n\n\n\n\nWe want leaders to be able see the player results. We'll next update the leader home page so they can.\n\n\nCreate a presentation component \njs/components/PlayerResultRow.js\n for displaying one player's results:\n\n\nimport\n \nReact\n \nfrom\n \n'react'\n;\n\n\nimport\n \nPropTypes\n \nfrom\n \n'prop-types'\n;\n\n\n\nfunction\n \nPlayerResultRow\n(\nprops\n)\n \n{\n\n  \nreturn\n \n(\n\n    \n<\ntr\n>\n\n      \n<\ntd\n>\n{\nprops\n.\nrunuser\n.\nemail\n}\n</\ntd\n>\n\n      \n<\ntd\n>\n{\nprops\n.\nperiodsPlayed\n}\n</\ntd\n>\n\n      \n<\ntd\n>\n{\nprops\n.\ntotal\n}\n</\ntd\n>\n\n    \n</\ntr\n>\n\n  \n);\n\n\n}\n\n\n\nPlayerResultRow\n.\npropTypes\n \n=\n \n{\n\n  \nrunuser\n:\n \nPropTypes\n.\nobject\n.\nisRequired\n,\n\n  \nperiodsPlayed\n:\n \nPropTypes\n.\nnumber\n.\nisRequired\n,\n\n  \ntotal\n:\n \nPropTypes\n.\nnumber\n.\nisRequired\n\n\n};\n\n\n\nexport\n \ndefault\n \nPlayerResultRow\n;\n\n\n\n\n\n\nwrap it in a smart component \njs/containers/PlayerResultRowContainer.js\n\n\nimport\n \n{\nconnect\n}\n \nfrom\n \n'react-redux'\n;\n\n\nimport\n \n{\nwithRouter\n}\n \nfrom\n \n'react-router'\n;\n\n\n\nimport\n \nPlayerResultRow\n \nfrom\n \n'../components/PlayerResultRow'\n;\n\n\n\nfunction\n \nmapStateToProps\n(\nstate\n,\n \nownProps\n)\n \n{\n\n  \nconst\n \nrunuser\n \n=\n \nownProps\n.\nrunuser\n;\n\n\n  \nconst\n \nscenario\n \n=\n \nstate\n.\nsimpl\n.\nscenario\n.\nfind\n(\n\n    \n(\ns\n)\n \n=>\n \nrunuser\n.\nid\n \n===\n \ns\n.\nrunuser\n\n  \n);\n\n\n  \nlet\n \nperiodsPlayed\n \n=\n \n0\n;\n\n  \nlet\n \ntotal\n \n=\n \n0\n;\n\n  \nif\n \n(\nscenario\n)\n \n{\n \n//\n \navoid\n \nruntime\n \nerrors\n \nwhile\n \nstate\n \nis\n \nloading\n\n    \nconst\n \nunsortedPeriods\n \n=\n \nstate\n.\nsimpl\n.\nperiod\n.\nfilter\n(\n\n      \n(\np\n)\n \n=>\n \nscenario\n.\nid\n \n===\n \np\n.\nscenario\n\n    \n);\n\n    \nconst\n \nperiods\n \n=\n \n_\n.\nsortBy\n(\nunsortedPeriods\n,\n \n(\np\n)\n \n=>\n \np\n.\norder\n);\n\n    \nconst\n \nperiodOrder\n \n=\n \n_\n.\nlast\n(\nperiods\n)\n.\norder\n;\n\n\n    \nif\n \n(\nperiodOrder\n \n>\n \n1\n)\n \n{\n \n//\n \npull\n \ntotal\n \nfrom\n \nlast\n \nresult\n\n      \nconst\n \nlastPeriod\n \n=\n \nperiods\n[\nperiodOrder\n \n-\n \n2\n];\n\n      \nperiodsPlayed\n \n=\n \nlastPeriod\n.\norder\n;\n\n\n      \nconst\n \nlastResult\n \n=\n \nstate\n.\nsimpl\n.\nresult\n.\nfind\n(\n\n        \n(\ns\n)\n \n=>\n \nlastPeriod\n.\nid\n \n===\n \ns\n.\nperiod\n\n      \n);\n\n      \ntotal\n \n=\n \nlastResult\n.\ndata\n.\ntotal\n;\n\n    \n}\n\n  \n}\n\n\n  \nreturn\n \n{\n\n    \nrunuser\n,\n\n    \nperiodsPlayed\n,\n\n    \ntotal\n\n  \n};\n\n\n}\n\n\n\nconst\n \nPlayerResultRowContainer\n \n=\n \nconnect\n(\n\n  \nmapStateToProps\n,\n\n  \nnull\n\n\n)(\nPlayerResultRow\n);\n\n\n\nexport\n \ndefault\n \nwithRouter\n(\nPlayerResultRowContainer\n);\n\n\n\n\n\n\nIn your \njs/modules/LeaderHome.js\n, replace the original contents with:\n\n\nimport\n \nReact\n \nfrom\n \n'react'\n;\n\n\nimport\n \nPropTypes\n \nfrom\n \n'prop-types'\n;\n\n\n\nimport\n \n{\nconnect\n}\n \nfrom\n \n'react-redux'\n;\n\n\n\nimport\n \nPlayerResultRowContainer\n \nfrom\n \n'../containers/PlayerResultRowContainer'\n\n\n\nclass\n \nLeaderHome\n \nextends\n \nReact\n.\nComponent\n \n{\n\n\n  \nrender\n()\n \n{\n\n    \nconst\n \nname\n \n=\n \nthis\n.\nprops\n.\nrunuser\n.\nfirst_name\n \n+\n \n' '\n \n+\n \nthis\n.\nprops\n.\nrunuser\n.\nlast_name\n;\n\n    \nconst\n \nplayerRows\n \n=\n \nthis\n.\nprops\n.\nplayers\n.\nmap\n(\n\n      \n(\np\n)\n \n=>\n \n<\nPlayerResultRowContainer\n \nkey\n=\n{\np\n.\nid\n}\n \nrunuser\n=\n{\np\n}\n/>\n\n    \n);\n\n    \nreturn\n \n(\n\n      \n<\ndiv\n>\n\n        \n<\ndiv\n>\n\n          \n<\nh1\n>\nHello\n \n{\nname\n}\n</\nh1\n>\n\n        \n</\ndiv\n>\n\n        \n<\ndiv\n>\n\n          \n<\ntable\n>\n\n            \n<\nthead\n>\n\n            \n<\ntr\n>\n\n              \n<\nth\n \nwidth\n=\n\"30%\"\n>\n \nPlayer\n</\nth\n>\n\n              \n<\nth\n \nwidth\n=\n\"30%\"\n>\n \nPeriods\n \nPlayed\n</\nth\n>\n\n              \n<\nth\n \nwidth\n=\n\"30%\"\n>\n \nTotal\n</\nth\n>\n\n            \n</\ntr\n>\n\n            \n</\nthead\n>\n\n            \n<\ntbody\n>\n\n            \n{\nplayerRows\n}\n\n            \n</\ntbody\n>\n\n          \n</\ntable\n>\n\n        \n</\ndiv\n>\n\n        \n<\nbr\n/>\n\n        \n<\na\n \nhref\n=\n\"/logout/\"\n \nclassName\n=\n\"btn btn-success btn-lg\"\n>\nLogout\n</\na\n>\n\n      \n</\ndiv\n>\n\n    \n);\n\n  \n}\n\n\n}\n\n\n\nLeaderHome\n.\npropTypes\n \n=\n \n{\n\n  \nrunuser\n:\n \nPropTypes\n.\nobject\n.\nisRequired\n,\n\n  \nplayers\n:\n \nPropTypes\n.\narray\n.\nisRequired\n\n\n};\n\n\n\nfunction\n \nmapStateToProps\n(\nstate\n)\n \n{\n\n  \nconst\n \nrunuser\n \n=\n \nstate\n.\nsimpl\n.\ncurrent_runuser\n;\n\n\n  \nconst\n \nunsortedPlayers\n \n=\n \nstate\n.\nsimpl\n.\nrunuser\n.\nfilter\n(\n\n    \n(\nru\n)\n \n=>\n \nrunuser\n.\nid\n \n!==\n \nru\n.\nid\n\n  \n);\n\n  \nconst\n \nplayers\n \n=\n \n_\n.\nsortBy\n(\nunsortedPlayers\n,\n \n(\np\n)\n \n=>\n \np\n.\nemail\n);\n\n\n  \nreturn\n \n{\n\n    \nrunuser\n,\n\n    \nplayers\n\n  \n};\n\n\n}\n\n\n\nconst\n \nmodule\n \n=\n \nconnect\n(\n\n  \nmapStateToProps\n,\n\n  \nnull\n\n\n)(\nLeaderHome\n);\n\n\n\nexport\n \ndefault\n \nmodule\n;\n\n\n\n\n\n\nNow when a leader logs in, they see the current player results:\n\n\n\n\nLet's add some styling to make it easier to read the table of results.\n\n\nIn \nfrontend/templates/frontend.home.html\n, replace\n\n\n  \n<head>\n\n  \n</head>\n\n\n\n\n\n\nwith\n\n\n  \n<head>\n\n    \n<style>\n\n    table, th, td { border: 1px solid black;  }\n    \n</style>\n\n  \n</head>\n\n\n\n\n\n\n\n\nTo see the revised leader page in action, open an incognito window and login into http://localhost:8000/ as 's2@calc.edu'.\n\n\n\n\nSubmit a decision in the 's2@calc.edu' window. The simpl state in both browser windows will update with a new result causing the leader home page to update accordingly.\n\n\n\n\nThis concludes our tutorial! We have barely scratched the surface. A completed example implementation is available at \ngithub.com:simplworld/simpl-calc-ui.git\n\nthat uses the game slug \nsimpl-calc\n.\n\n\nThere's much more that you can do with Simpl. For more informations, check out the service-specific documentation.",
            "title": "Build the Single Player Front End"
        },
        {
            "location": "/tutorials/single-player/frontend/#building-the-frontend-ui",
            "text": "",
            "title": "Building the Frontend UI"
        },
        {
            "location": "/tutorials/single-player/frontend/#prerequisites",
            "text": "This tutorial assumes you already the following software installed:   Node >= 5.7.0  NPM >= 3.6.0    Note  This tutorial assumes you still have both the  Games API service  (http://localhost:8100/) and the  Model service  (http://localhost:8080/) running.  Please open up an additional terminal window and SSH into the Vagrant box before continuing.",
            "title": "Prerequisites"
        },
        {
            "location": "/tutorials/single-player/frontend/#installation",
            "text": "First, create a new virtualenv called 'calc-ui':  $ mkvirtualenv calc-ui  Then, install the  cookiecutter  Python package:  $ pip install cookiecutter  Change to the  /vagrant/projects  folder:  $  cd  projects  Use  cookiecutter  to create the boilerplate for your app  $ cookiecutter https://github.com:simplworld/simpl-ui-cookiecutter.git  Make sure the value for  game_slug  is the same slug you used in the  modelservice tutorial . If you are using defaults from the tutorial,\nthen the slug should be  calc . For all other values you can use the default for the project, or choose your own.  For example,  project_name   [ Simulation   UI ] :   Calc   UI  repo_slug   [ calc - ui ] :  project_slug   [ calc_ui ] :  game_slug   [ calc - ui ] :   calc  modelservice_slug   [ calc - model ] :  topic_root   [ world . simpl ] :  app_slug   [ frontend ] :  version   [ 0.1.0 ] :   After the project layout is created,  cd  into your repo directory and install the requirements:  $ pip install -r requirements.txt  Outside of Vagrant,  cd  into your your repo directory, install the JavaScript node modules and run gulp to keep the web server's javascript updated as you work on the frontend:  $ npm install\n$ gulp  To aid development, you can install the following Chrome DevTools Extensions:   Redux DevTools Extension  React Developer Tools   It is also recommended to configure your editor to integrate with ESLint:   PyCharm  SublimeText2",
            "title": "Installation"
        },
        {
            "location": "/tutorials/single-player/frontend/#configuration",
            "text": "Just like most Websites, the frontend service will need a place where it can store information about sessions and their users. The users' specific information will be fetched from the  Simple Games API  and kept in sync automatically.   Note  For the purposes of this tutorial we're going to use SQLite, but this can be changed to match whatever database backend you prefer. In a production environment, you'll likely want to switch to something like PostgreSQL.   First, let's create the necessary local tables:  $ ./manage.py migrate  Then, start your frontend service with:  $ ./manage.py runserver  0 .0.0.0:8000  In Chrome, head to  http://localhost:8000/  and login as 's1@calc.edu' with password 's1'.\nOnce you are logged in, you should see the 'Hello Player' message of the skeleton app.   Open Chrome's DevTools, and select the 'Redux' tab. You will see a list of actions, and the\ncurrent  state  of the store. Note that the state has a property named  simpl . Expand the  simpl  property\nto see all the scope properties associated with the current user.   This properties will be updated as the model service adds, removes or updates scopes.\nYou will connect your components to the properties and they will update accordingly.  Next, logout by going to  localhost:8000/logout/  in your browser. Then login as leader@calc.edu with password 'leader'.\nOnce you are logged in, you should see the 'Hello Leader' message of the skeleton app. If you look at the  simpl \nstate properties, they look similar to those of players. Only information about the current user has been loaded.   In a multi-player simulation, players are assigned to a world with other players.\nThe cookiecutter template assumes you are implementing a multi-player simulation in which players\nsee only their own and their world's data. By default, leaders can see the worlds and users in their subscribed runs,\nbut not the scenarios of other users. Consequently, the template  js/modules/Root.js  sets the simpl decorator's loadAllScenarios argument false to block access to scenarios of other users.  We want Calc leaders to have access to all information on all players in their runs. Since Calc players are not associated with\na world, we need to modify the template  js/modules/Root.js  code to load all player scenarios for leaders.  In your  js/modules/Root.js :  export default simpl({\n  authid: AUTHID,\n  password: 'nopassword',\n  url: ` ${ MODEL_SERVICE } `,\n  progressComponent: Progress,\n  root_topic: ROOT_TOPIC,\n  topics: () => topics,\n  loadAllScenarios: false\n})(RootContainer);  change the simpl decorator's loadAllScenarios argument to LEADER:  export default simpl({\n  authid: AUTHID,\n  password: 'nopassword',\n  url: ` ${ MODEL_SERVICE } `,\n  progressComponent: Progress,\n  root_topic: ROOT_TOPIC,\n  topics: () => topics,\n  loadAllScenarios: LEADER\n})(RootContainer);  Refresh your Chrome browser page and you'll see all the run's runusers have been loaded into the  simpl  state.   These properties will be updated as the model service adds, removes or updates scopes. You will connect your components to the properties and they will update accordingly.",
            "title": "Configuration"
        },
        {
            "location": "/tutorials/single-player/frontend/#implementation",
            "text": "To implement your UI, you will write Smart Components and Presentational Components.  The Presentational Components will provide the necessary markup to render UI elements, while the Smart Components will wrap them providing the necessary data.  First, create an action in  js/actions/Actions.js  for submitting decisions to the  submit_decision  topic defined by calc-model  game/games.py .  import   { createAction }   from   'redux-actions' ;  import   AutobahnReact   from   'simpl/lib/autobahn' ;  //   submit   player   decision   and   advance   to   next   period  export   const   submitDecision   = \n     createAction ( 'SUBMIT_DECISION' ,   ( period ,   operand ,   ... args )   => \n         AutobahnReact . publish ( `model:model.period.${period.id}.submit_decision` ,   [ operand ]) \n     );   Note the action publishes to the topic because the calc-model  game/games.py submit_decision` endpoint subscribes to the topic.  Create a presentation component  js/components/DecisionForm.js  for entering player decisions:  import   React   from   'react' ;  import   PropTypes   from   'prop-types' ;  import   { Button }   from   'react-bootstrap' ;  import   { Field ,   reduxForm }   from   'redux-form' ;  class   DecisionForm   extends   React . Component   { \n\n   constructor ( props )   { \n     super ( props ); \n     this . submitForm   =   this . submitForm . bind ( this ); \n   } \n\n   submitForm ( values )   { \n     this . props . submitDecision ( values ); \n   } \n\n   render ()   { \n     const   { error ,   handleSubmit ,   submitting ,   invalid }   =   this . props ; \n     return   ( \n       < div   className = \"content-wrapper\" > \n         < form   id = \"testScenarioForm\"   onSubmit = { handleSubmit ( this . submitForm )} > \n\n           < div   className = \"form-group\" > \n             < label > Enter   a   number : </ label > \n             < Field \n               component = \"input\" \n               type = \"number\" \n               name = \"operand\" \n               id = \"operand\" \n               required = \"true\" \n               step = \"any\" \n             /> \n           </ div > \n\n           < div > \n             < Button \n               type = \"submit\" \n               bsClass = \"btn btn-mr btn-labeled btn-success\" \n               bsStyle = \"success\" \n               disabled = { invalid   ||   submitting } \n             > Add   to   Total </ Button > \n           </ div > \n\n           < div > \n             { error   &&   < div >< p > { error } </ p ></ div > } \n           </ div > \n\n         </ form > \n       </ div   > \n     ); \n   }  }  DecisionForm . propTypes   =   { \n   runuser :   PropTypes . object . isRequired , \n   initialValues :   PropTypes . object . isRequired , \n\n   //   redux - form   props \n   handleSubmit :   PropTypes . func , \n   invalid :   PropTypes . bool , \n   submitting :   PropTypes . bool , \n   error :   PropTypes . string , \n\n   //   dispatch   actions \n   submitDecision :   PropTypes . func . isRequired  };  export   default   reduxForm ({ \n   form :   'decisionForm'  })( DecisionForm );   wrap it in a smart component  js/containers/DecisionFormContainer.js  import   { connect }   from   'react-redux' ;  import   { withRouter }   from   'react-router' ;  import   DecisionForm   from   '../components/DecisionForm' ;  import   { submitDecision }   from   '../actions/Actions' ;  function   mapStateToProps ( state ,   ownProps )   { \n   const   initialValues   =   { \n     'operand' :   0 \n   }; \n   return   { \n     runuser :   state . simpl . current_runuser , \n     initialValues \n   };  }  function   mapDispatchToProps ( dispatch ,   ownProps )   { \n   return   { \n     submitDecision ( values )   { \n       //   submit   player 's decision \n       const   operand   =   values . operand ; \n       dispatch ( submitDecision ( ownProps . currentPeriod ,   operand )) \n     } \n   };  }  const   DecisionFormContainer   =   connect ( \n   mapStateToProps , \n   mapDispatchToProps  )( DecisionForm );  export   default   withRouter ( DecisionFormContainer );   In your  js/modules/PlayerHome.js , replace the original contents with:  import   React   from   'react' ;  import   PropTypes   from   'prop-types' ;  import   { connect }   from   'react-redux' ;  import   DecisionFormContainer   from   '../containers/DecisionFormContainer'  class   PlayerHome   extends   React . Component   { \n   render ()   { \n     return   ( \n       < div > \n         < h1 > Hello   Player :   { this . props . runuser . email } </ h1 > \n         < p > Current   total :   { this . props . total } </ p > \n         < DecisionFormContainer   currentPeriod = { this . props . currentPeriod } /> \n         < br /> \n         < a   href = \"/logout/\"   className = \"btn btn-success btn-lg\" > Logout </ a > \n       </ div > \n     ); \n   }  }  PlayerHome . propTypes   =   { \n   runuser :   PropTypes . object . isRequired , \n   total :   PropTypes . number , \n   currentPeriod :   PropTypes . object . isRequired ,  };  function   mapStateToProps ( state )   { \n   const   runuser   =   state . simpl . current_runuser ; \n\n   const   scenario   =   state . simpl . scenario . find ( \n     ( s )   =>   runuser . id   ===   s . runuser \n   ); \n\n   const   unsortedPeriods   =   state . simpl . period . filter ( \n     ( p )   =>   scenario . id   ===   p . scenario \n   ); \n   const   periods   =   _ . sortBy ( unsortedPeriods ,   ( p )   =>   p . order ); \n   const   periodOrder   =   _ . last ( periods ) . order ; \n\n   let   total   =   0 ; \n   if   ( periodOrder   >   1 )   {   //   pull   total   from   last   result \n     const   lastPeriod   =   periods [ periodOrder   -   2 ]; \n     const   lastResult   =   state . simpl . result . find ( \n       ( s )   =>   lastPeriod . id   ===   s . period \n     ); \n     total   =   lastResult . data . total ; \n   } \n\n   const   currentPeriod   =   periods [ periodOrder   -   1 ]; \n\n   return   { \n     runuser , \n     total , \n     currentPeriod \n   };  }  const   module   =   connect ( \n   mapStateToProps , \n   null  )( PlayerHome );  export   default   module ;   Now when a player logs in, they see a form for entering decisions and a logout link:   As the player submits decisions, the redux state automatically updates with new periods, decisions and results:   We want leaders to be able see the player results. We'll next update the leader home page so they can.  Create a presentation component  js/components/PlayerResultRow.js  for displaying one player's results:  import   React   from   'react' ;  import   PropTypes   from   'prop-types' ;  function   PlayerResultRow ( props )   { \n   return   ( \n     < tr > \n       < td > { props . runuser . email } </ td > \n       < td > { props . periodsPlayed } </ td > \n       < td > { props . total } </ td > \n     </ tr > \n   );  }  PlayerResultRow . propTypes   =   { \n   runuser :   PropTypes . object . isRequired , \n   periodsPlayed :   PropTypes . number . isRequired , \n   total :   PropTypes . number . isRequired  };  export   default   PlayerResultRow ;   wrap it in a smart component  js/containers/PlayerResultRowContainer.js  import   { connect }   from   'react-redux' ;  import   { withRouter }   from   'react-router' ;  import   PlayerResultRow   from   '../components/PlayerResultRow' ;  function   mapStateToProps ( state ,   ownProps )   { \n   const   runuser   =   ownProps . runuser ; \n\n   const   scenario   =   state . simpl . scenario . find ( \n     ( s )   =>   runuser . id   ===   s . runuser \n   ); \n\n   let   periodsPlayed   =   0 ; \n   let   total   =   0 ; \n   if   ( scenario )   {   //   avoid   runtime   errors   while   state   is   loading \n     const   unsortedPeriods   =   state . simpl . period . filter ( \n       ( p )   =>   scenario . id   ===   p . scenario \n     ); \n     const   periods   =   _ . sortBy ( unsortedPeriods ,   ( p )   =>   p . order ); \n     const   periodOrder   =   _ . last ( periods ) . order ; \n\n     if   ( periodOrder   >   1 )   {   //   pull   total   from   last   result \n       const   lastPeriod   =   periods [ periodOrder   -   2 ]; \n       periodsPlayed   =   lastPeriod . order ; \n\n       const   lastResult   =   state . simpl . result . find ( \n         ( s )   =>   lastPeriod . id   ===   s . period \n       ); \n       total   =   lastResult . data . total ; \n     } \n   } \n\n   return   { \n     runuser , \n     periodsPlayed , \n     total \n   };  }  const   PlayerResultRowContainer   =   connect ( \n   mapStateToProps , \n   null  )( PlayerResultRow );  export   default   withRouter ( PlayerResultRowContainer );   In your  js/modules/LeaderHome.js , replace the original contents with:  import   React   from   'react' ;  import   PropTypes   from   'prop-types' ;  import   { connect }   from   'react-redux' ;  import   PlayerResultRowContainer   from   '../containers/PlayerResultRowContainer'  class   LeaderHome   extends   React . Component   { \n\n   render ()   { \n     const   name   =   this . props . runuser . first_name   +   ' '   +   this . props . runuser . last_name ; \n     const   playerRows   =   this . props . players . map ( \n       ( p )   =>   < PlayerResultRowContainer   key = { p . id }   runuser = { p } /> \n     ); \n     return   ( \n       < div > \n         < div > \n           < h1 > Hello   { name } </ h1 > \n         </ div > \n         < div > \n           < table > \n             < thead > \n             < tr > \n               < th   width = \"30%\" >   Player </ th > \n               < th   width = \"30%\" >   Periods   Played </ th > \n               < th   width = \"30%\" >   Total </ th > \n             </ tr > \n             </ thead > \n             < tbody > \n             { playerRows } \n             </ tbody > \n           </ table > \n         </ div > \n         < br /> \n         < a   href = \"/logout/\"   className = \"btn btn-success btn-lg\" > Logout </ a > \n       </ div > \n     ); \n   }  }  LeaderHome . propTypes   =   { \n   runuser :   PropTypes . object . isRequired , \n   players :   PropTypes . array . isRequired  };  function   mapStateToProps ( state )   { \n   const   runuser   =   state . simpl . current_runuser ; \n\n   const   unsortedPlayers   =   state . simpl . runuser . filter ( \n     ( ru )   =>   runuser . id   !==   ru . id \n   ); \n   const   players   =   _ . sortBy ( unsortedPlayers ,   ( p )   =>   p . email ); \n\n   return   { \n     runuser , \n     players \n   };  }  const   module   =   connect ( \n   mapStateToProps , \n   null  )( LeaderHome );  export   default   module ;   Now when a leader logs in, they see the current player results:   Let's add some styling to make it easier to read the table of results.  In  frontend/templates/frontend.home.html , replace     <head> \n   </head>   with     <head> \n     <style> \n    table, th, td { border: 1px solid black;  }\n     </style> \n   </head>    To see the revised leader page in action, open an incognito window and login into http://localhost:8000/ as 's2@calc.edu'.   Submit a decision in the 's2@calc.edu' window. The simpl state in both browser windows will update with a new result causing the leader home page to update accordingly.   This concludes our tutorial! We have barely scratched the surface. A completed example implementation is available at  github.com:simplworld/simpl-calc-ui.git \nthat uses the game slug  simpl-calc .  There's much more that you can do with Simpl. For more informations, check out the service-specific documentation.",
            "title": "Implementation"
        },
        {
            "location": "/services/simpl-users/",
            "text": "Welcome to Simpl-Games-API\n\n\nTBD",
            "title": "simpl-users"
        },
        {
            "location": "/services/simpl-users/#welcome-to-simpl-games-api",
            "text": "TBD",
            "title": "Welcome to Simpl-Games-API"
        },
        {
            "location": "/services/Simpl-Games-API/",
            "text": "Welcome to Simpl-Games\n\n\nFor development purposes, the Simpl-Games service is run on port 8100.\n\n\nOnce the service is running, you can access:\n\n\n\n\nAPI Docs\n\n\nThe \nSimpl api\n\n\nSimpl Frontend Admin\n\n\nDjango Admin\n but only if you need it!",
            "title": "Simpl-Games-API"
        },
        {
            "location": "/services/Simpl-Games-API/#welcome-to-simpl-games",
            "text": "For development purposes, the Simpl-Games service is run on port 8100.  Once the service is running, you can access:   API Docs  The  Simpl api  Simpl Frontend Admin  Django Admin  but only if you need it!",
            "title": "Welcome to Simpl-Games"
        },
        {
            "location": "/services/modelservice/games/",
            "text": "Games\n\n\nScopes\n\n\nEvery game is defined by building what we call the \nScope tree\n.\n\n\nThe \nScope tree\n starts at \nGame\n, and it's defined as follow:\n\n\n\n\nGame\n\n\nPhase\n\n\nRole\n\n\nRun\n\n\nRunUser\n\n\nWorld\n\n\nScenario\n\n\nPeriod\n\n\nDecision\n\n\nResult\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe \nmodelservice.games\n module provides all the base classes to build this tree. Each of this classes is considered a \nScope\n. The logic of your game will be implemented by subclassing the necessary scope and adding your own custom logic.\n\n\nYour game is defined by registering your top-level Scope with the \nmodelservices.games.game\n decorator.\n\n\nInside any Scope, you can make any method callable from javascript by decorating it with the \nmodelservice.games.register\n decorator.\nSimilarly, you can use the \nmodelservice.games.subscribe\n decorator to subscribe any method to a topic:\n\n\nfrom\n \nmodelservice.games\n \nimport\n \nScenario\n,\n \nGame\n\n\nfrom\n \nmodelservice.games\n \nimport\n \nregister\n,\n \nsubscribe\n\n\n\n\nclass\n \nZeroSumScenario\n(\nScenario\n):\n\n    \nplayers\n \n=\n \n{}\n\n\n    \n@register\n\n    \ndef\n \nadd\n(\nself\n,\n \nterm1\n,\n \nterm2\n,\n \ndetails\n):\n\n        \nreturn\n \nterm1\n \n+\n \nterm2\n\n\n    \n@subscribe\n\n    \ndef\n \nplayer_quit\n(\nself\n,\n \nplayer\n,\n \nreason\n,\n \ndetails\n):\n\n        \nself\n.\nplayers\n.\npop\n(\nplayer\n[\n'id'\n])\n\n\n\nGame\n.\nregister\n(\n'zero-sum'\n,\n \n[\nZeroSumScenario\n])\n\n\n\n\n\n\nIn this example, \nZeroSumScenario.add\n will be registered at the uri \n{settings.ROOT_URI}.models.{resource_name}.{scope_pk}.add\n\n and \nZeroSumScenario.player_quit\n will subscribe to \n{settings.ROOT_URI}.models.resource_name}.{scope_pk}.player_quit\n.\n\n\nAlternatively, the name that will be used for the topic can be passed to the decorator:\n\n\nclass\n \nZeroSumScenario\n(\nScenario\n):\n\n\n    \n@subscribe\n(\n'player.quit'\n)\n\n    \ndef\n \nplayer_quit\n(\nself\n,\n \nplayer\n,\n \nreason\n):\n\n        \nself\n.\nplayers\n.\npop\n(\nplayer\n[\n'id'\n])\n\n\n\nGame\n.\nregister\n(\n'zero-sum'\n,\n \n[\nZeroSumScenario\n])\n\n\n\n\n\n\nZeroSumScenario.player_quit\n will now be subscribed to \n{settings.ROOT_URI}.models.{resource_name}.{scope_pk}.player.quit\n.\n\n\nFurther customization can be achieved by overriding the \nScope.get_routing(name)\n method.\n\n\nScope methods\n\n\nAll \nScopes\n inherit from a common \nScope\n subclass and share these common methods among many others:\n\n\n\n\n.get_routing(name)\n: given a topic short name, returns the full topic path. This is to avoid repeating the same topic namespace over and over, and allow using shorter topic names.\n\n\n.publish(topic, *args, **kwargs)\n: Publishes a message on the specified \ntopic\n. The actual topic name will be what is returned by \n.get_routing(topic)\n \n\n\n.save()\n: Persist the scope by submitting it to the \nSimpl-Games-API\n service.\n\n\n.get_scope()\n: Registered procedure at \n{scope.topic}.get_scope\n returning the scope's serialized version. Call this procedure if you want to retrieve the scope's state from the UI\n\n\n.get_scope_tree()\n: Same as \n.get_scope\n, but will also walk down the tree from scope, returning its children recursively.\n\n\n.onConnected()\n\n\n.onStop()\n\n\n.onStart()\n\n\n\n\nScope properties\n\n\nAll \nScopes\n inherits from a common \nScope\n subclass and share these common properties among many others:\n\n\n\n\n.pk\n: The scopes primary key\n\n\n.json\n: A \ndict\n that contains the serialized representation of the scope. This is what will be passed to the browser\nand to the Simpl-Games-API service. Any user-defined state for the scope should be stored in \n.json['data']\n\n\n.game\n: The \nGame\n with which this scope belongs.\n\n\n.child_scopes\n: A \nScopeManager\n of the children scope.\n\n\n.games_client\n: An instance of a REST API client for the Simpl-Games service.\n\n\n.my\n: This special property will contain scopes that are related to the scope. See \nTraversing Scopes\n for more details.\n\n\n.log\n: a \ntxaio\n logging instance. See \"Logging\" below.\n\n\n\n\nLogging\n\n\nTo log from a \nScope\n, you can use the \n.log\n attribute.\n\n\nThe best practice is to use a string with the \nr\n formatting operator for your variables. For example, if you'd want to log the \nsomevar\n variable to the \nINFO\n level, you'd use:\n\n\nmyscope.log.info(\"Something happened: {myvar!r}\", myvar=somevar)\n\n\n\n\n\nConcrete Classes\n\n\nFor convenience, the following scopes are defined in \nmodelservices.games\n:\n\n\n\n\nmodelservices.games.Game\n\n\nmodelservices.games.Phase\n\n\nmodelservices.games.Role\n\n\nmodelservices.games.Run\n\n\nmodelservices.games.World\n\n\nmodelservices.games.RunUser\n\n\nmodelservices.games.Scenario\n\n\nmodelservices.games.Period\n\n\nmodelservices.games.Decision\n\n\nmodelservices.games.Result\n\n\n\n\nmodelservices.games.Game\n\n\nIn addition to the methods inherited from \nScope\n, \nGame\n has the following methods:\n\n\n\n\n.get_phases()\n: Registered procedure to fetch the game's phases over WAMP.\n\n\n.get_roles()\n: Registered procedure to fetch the game's roles over WAMP.\n\n\n\n\nIn addition to the properties inherited from \nScope\n, \nGame\n has the following properties:\n\n\n\n\n.phases\n: A list of the game's \nPhase\ns.\n\n\n.roles\n: A list of the game's \nRoles\ns.\n\n\n.runs\n: A list of the game's \nRun\ns.\n\n\n\n\nmodelservices.games.Run\n\n\nIn addition to the methods inherited from \nScope\n, \nRun\n has the following methods:\n\n\n\n\n.advance_phase()\n: Subscribed method to make the \nRun\n advance to the next phase.\n\n\n.on_advance_phase(next_phase)\n: Override this method to perform custom logic right after the run is advanced to the next phase.\n\n\n.rollback_phase()\n: Subscribed method to make the \nRun\n rollback to the previous phase.\n\n\n.on_rollback_phase(previous_phase)\n: Override this method to perform custom logic right after the run is rolled back to the previous phase.\n\n\n\n\nIn addition to the properties inherited from \nScope\n, \nRun\n has the following properties:\n\n\n\n\n.current_phase\n: The Run's current phase.\n\n\n.worlds\n: A list of \nWorld\ns within this \nRun\n\n\n.runusers\n: A list of \nRunUsers\ns within this \nRun\n\n\n\n\nmodelservices.games.World\n\n\nIn addition to the properties inherited from \nScope\n, \nWorld\n has the following properties:\n\n\n\n\n.run\n: The Run to which this World belongs.\n\n\n.scenarios\n: A list of the World's \nScenarios\ns.\n\n\n.runusers\n: A list of the World's \nRunUser\ns.\n\n\n\n\nmodelservices.games.RunUser\n\n\nIn addition to the methods inherited from \nScope\n, \nRunUser\n has the following methods:\n\n\n\n\n.get_scenarios()\n: Registered procedure to fetch the RunUser's Scenarios over WAMP.\n\n\n\n\nIn addition to the properties inherited from \nScope\n, \nRun\n has the following properties:\n\n\n\n\n.run\n: The Run to which this Runuser belongs.\n\n\n.scenarios\n: A list of the RunUser's \nScenarios\ns.\n\n\n.leader\n: Flags whether the RunUser is a leader or a player in this \nRun\n.\n\n\n.role\n: The RunUser's \nRole\n if the user is a player in this \nRun\n.\n\n\n.world\n: The RunUser's \nWorld\n if the user is a player in this \nRun\n and belongs to a \nWorld\n.\n\n\n\n\nmodelservices.games.Scenario\n\n\nIn addition to the properties inherited from \nScope\n, \nScenario\n has the following properties:\n\n\n\n\n.periods\n: A list of the Scenario's \nPeriod\n's.\n\n\n.world\n: returns the \nWorld\n to which the Scenario belongs or \nNone\n if the Scenario doesn't belong to a \nWorld\n.\n\n\n.runuser\n: returns the \nRunuser\n to which the Scenario belongs or \nNone\n if the Scenario doesn't belong to a \nRunuser\n.\n\n\n\n\nmodelservices.games.Period\n\n\nIn addition to the properties inherited from \nScope\n, \nPeriod\n has the following properties:\n\n\n\n\n.decisions\n: A list of the Period's \nDecisions\ns.\n\n\n.results\n: A list of the Period's \nResult\ns.\n\n\n.scenario\n: returns the \nScenario\n to which the Period belongs.\n\n\n\n\nmodelservices.games.Decision\n\n\nIn addition to the properties inherited from \nScope\n, \nDecision\n has the following properties:\n\n\n\n\n.period\n: returns the \nPeriod\n to which the Decision belongs.\n\n\n.role\n: returns the Decision's \nRole\n.\n\n\n\n\nmodelservices.games.Result\n\n\nIn addition to the properties inherited from \nScope\n, \nResult\n has the following properties:\n\n\n\n\n.period\n: returns the \nPeriod\n to which the Result belongs.\n\n\n.role\n: returns the Result's \nRole\n.",
            "title": "Scopes"
        },
        {
            "location": "/services/modelservice/games/#games",
            "text": "",
            "title": "Games"
        },
        {
            "location": "/services/modelservice/games/#scopes",
            "text": "Every game is defined by building what we call the  Scope tree .  The  Scope tree  starts at  Game , and it's defined as follow:   Game  Phase  Role  Run  RunUser  World  Scenario  Period  Decision  Result             The  modelservice.games  module provides all the base classes to build this tree. Each of this classes is considered a  Scope . The logic of your game will be implemented by subclassing the necessary scope and adding your own custom logic.  Your game is defined by registering your top-level Scope with the  modelservices.games.game  decorator.  Inside any Scope, you can make any method callable from javascript by decorating it with the  modelservice.games.register  decorator.\nSimilarly, you can use the  modelservice.games.subscribe  decorator to subscribe any method to a topic:  from   modelservice.games   import   Scenario ,   Game  from   modelservice.games   import   register ,   subscribe  class   ZeroSumScenario ( Scenario ): \n     players   =   {} \n\n     @register \n     def   add ( self ,   term1 ,   term2 ,   details ): \n         return   term1   +   term2 \n\n     @subscribe \n     def   player_quit ( self ,   player ,   reason ,   details ): \n         self . players . pop ( player [ 'id' ])  Game . register ( 'zero-sum' ,   [ ZeroSumScenario ])   In this example,  ZeroSumScenario.add  will be registered at the uri  {settings.ROOT_URI}.models.{resource_name}.{scope_pk}.add \n and  ZeroSumScenario.player_quit  will subscribe to  {settings.ROOT_URI}.models.resource_name}.{scope_pk}.player_quit .  Alternatively, the name that will be used for the topic can be passed to the decorator:  class   ZeroSumScenario ( Scenario ): \n\n     @subscribe ( 'player.quit' ) \n     def   player_quit ( self ,   player ,   reason ): \n         self . players . pop ( player [ 'id' ])  Game . register ( 'zero-sum' ,   [ ZeroSumScenario ])   ZeroSumScenario.player_quit  will now be subscribed to  {settings.ROOT_URI}.models.{resource_name}.{scope_pk}.player.quit .  Further customization can be achieved by overriding the  Scope.get_routing(name)  method.",
            "title": "Scopes"
        },
        {
            "location": "/services/modelservice/games/#scope-methods",
            "text": "All  Scopes  inherit from a common  Scope  subclass and share these common methods among many others:   .get_routing(name) : given a topic short name, returns the full topic path. This is to avoid repeating the same topic namespace over and over, and allow using shorter topic names.  .publish(topic, *args, **kwargs) : Publishes a message on the specified  topic . The actual topic name will be what is returned by  .get_routing(topic)    .save() : Persist the scope by submitting it to the  Simpl-Games-API  service.  .get_scope() : Registered procedure at  {scope.topic}.get_scope  returning the scope's serialized version. Call this procedure if you want to retrieve the scope's state from the UI  .get_scope_tree() : Same as  .get_scope , but will also walk down the tree from scope, returning its children recursively.  .onConnected()  .onStop()  .onStart()",
            "title": "Scope methods"
        },
        {
            "location": "/services/modelservice/games/#scope-properties",
            "text": "All  Scopes  inherits from a common  Scope  subclass and share these common properties among many others:   .pk : The scopes primary key  .json : A  dict  that contains the serialized representation of the scope. This is what will be passed to the browser\nand to the Simpl-Games-API service. Any user-defined state for the scope should be stored in  .json['data']  .game : The  Game  with which this scope belongs.  .child_scopes : A  ScopeManager  of the children scope.  .games_client : An instance of a REST API client for the Simpl-Games service.  .my : This special property will contain scopes that are related to the scope. See  Traversing Scopes  for more details.  .log : a  txaio  logging instance. See \"Logging\" below.",
            "title": "Scope properties"
        },
        {
            "location": "/services/modelservice/games/#logging",
            "text": "To log from a  Scope , you can use the  .log  attribute.  The best practice is to use a string with the  r  formatting operator for your variables. For example, if you'd want to log the  somevar  variable to the  INFO  level, you'd use:  myscope.log.info(\"Something happened: {myvar!r}\", myvar=somevar)",
            "title": "Logging"
        },
        {
            "location": "/services/modelservice/games/#concrete-classes",
            "text": "For convenience, the following scopes are defined in  modelservices.games :   modelservices.games.Game  modelservices.games.Phase  modelservices.games.Role  modelservices.games.Run  modelservices.games.World  modelservices.games.RunUser  modelservices.games.Scenario  modelservices.games.Period  modelservices.games.Decision  modelservices.games.Result",
            "title": "Concrete Classes"
        },
        {
            "location": "/services/modelservice/games/#modelservicesgamesgame",
            "text": "In addition to the methods inherited from  Scope ,  Game  has the following methods:   .get_phases() : Registered procedure to fetch the game's phases over WAMP.  .get_roles() : Registered procedure to fetch the game's roles over WAMP.   In addition to the properties inherited from  Scope ,  Game  has the following properties:   .phases : A list of the game's  Phase s.  .roles : A list of the game's  Roles s.  .runs : A list of the game's  Run s.",
            "title": "modelservices.games.Game"
        },
        {
            "location": "/services/modelservice/games/#modelservicesgamesrun",
            "text": "In addition to the methods inherited from  Scope ,  Run  has the following methods:   .advance_phase() : Subscribed method to make the  Run  advance to the next phase.  .on_advance_phase(next_phase) : Override this method to perform custom logic right after the run is advanced to the next phase.  .rollback_phase() : Subscribed method to make the  Run  rollback to the previous phase.  .on_rollback_phase(previous_phase) : Override this method to perform custom logic right after the run is rolled back to the previous phase.   In addition to the properties inherited from  Scope ,  Run  has the following properties:   .current_phase : The Run's current phase.  .worlds : A list of  World s within this  Run  .runusers : A list of  RunUsers s within this  Run",
            "title": "modelservices.games.Run"
        },
        {
            "location": "/services/modelservice/games/#modelservicesgamesworld",
            "text": "In addition to the properties inherited from  Scope ,  World  has the following properties:   .run : The Run to which this World belongs.  .scenarios : A list of the World's  Scenarios s.  .runusers : A list of the World's  RunUser s.",
            "title": "modelservices.games.World"
        },
        {
            "location": "/services/modelservice/games/#modelservicesgamesrunuser",
            "text": "In addition to the methods inherited from  Scope ,  RunUser  has the following methods:   .get_scenarios() : Registered procedure to fetch the RunUser's Scenarios over WAMP.   In addition to the properties inherited from  Scope ,  Run  has the following properties:   .run : The Run to which this Runuser belongs.  .scenarios : A list of the RunUser's  Scenarios s.  .leader : Flags whether the RunUser is a leader or a player in this  Run .  .role : The RunUser's  Role  if the user is a player in this  Run .  .world : The RunUser's  World  if the user is a player in this  Run  and belongs to a  World .",
            "title": "modelservices.games.RunUser"
        },
        {
            "location": "/services/modelservice/games/#modelservicesgamesscenario",
            "text": "In addition to the properties inherited from  Scope ,  Scenario  has the following properties:   .periods : A list of the Scenario's  Period 's.  .world : returns the  World  to which the Scenario belongs or  None  if the Scenario doesn't belong to a  World .  .runuser : returns the  Runuser  to which the Scenario belongs or  None  if the Scenario doesn't belong to a  Runuser .",
            "title": "modelservices.games.Scenario"
        },
        {
            "location": "/services/modelservice/games/#modelservicesgamesperiod",
            "text": "In addition to the properties inherited from  Scope ,  Period  has the following properties:   .decisions : A list of the Period's  Decisions s.  .results : A list of the Period's  Result s.  .scenario : returns the  Scenario  to which the Period belongs.",
            "title": "modelservices.games.Period"
        },
        {
            "location": "/services/modelservice/games/#modelservicesgamesdecision",
            "text": "In addition to the properties inherited from  Scope ,  Decision  has the following properties:   .period : returns the  Period  to which the Decision belongs.  .role : returns the Decision's  Role .",
            "title": "modelservices.games.Decision"
        },
        {
            "location": "/services/modelservice/games/#modelservicesgamesresult",
            "text": "In addition to the properties inherited from  Scope ,  Result  has the following properties:   .period : returns the  Period  to which the Result belongs.  .role : returns the Result's  Role .",
            "title": "modelservices.games.Result"
        },
        {
            "location": "/services/modelservice/traversing/",
            "text": "Traversing Scopes\n\n\nEvery Scope has a \n.my\n attribute that can be user to reach other scopes that are related to a specific instance.\n\n\nFor example, to get the parent scope of \nmyscope\n, you can use \nscope.my.parent\n.\n\n\nFrom any Scope, you can reach the following scope:\n\n\n\n\n.game\n. The instance of the root (ie: top-level) scope in the chain. Think of this as the 'global' state for this game.\n\n\n.run\n. The instance of the \nrun\n scope in the chain. This will be only set for scopes downstream from any run.\n\n\n.world\n. The instance of the `worlds scope in the chain. This will be only set for scopes downstream from any world.\n\n\n.parent\n. The parent scope. This represent 'one level above' in the scope chain.\n\n\n\n\nAdditionally, the following methods are available:\n\n\n\n\n.get_runusers(leader=False)\n: Returns a \nScopeManager\n of \nRunUser\ns that have access to the scope. If \nleader\n is True and the scope is a world, returns all RunUsers for the World's Run\n\n\n.get_users(leader=False)\n: returns a list of user ids (not runuser ids) from \nget_runusers\n.",
            "title": "Traversing Scopes"
        },
        {
            "location": "/services/modelservice/traversing/#traversing-scopes",
            "text": "Every Scope has a  .my  attribute that can be user to reach other scopes that are related to a specific instance.  For example, to get the parent scope of  myscope , you can use  scope.my.parent .  From any Scope, you can reach the following scope:   .game . The instance of the root (ie: top-level) scope in the chain. Think of this as the 'global' state for this game.  .run . The instance of the  run  scope in the chain. This will be only set for scopes downstream from any run.  .world . The instance of the `worlds scope in the chain. This will be only set for scopes downstream from any world.  .parent . The parent scope. This represent 'one level above' in the scope chain.   Additionally, the following methods are available:   .get_runusers(leader=False) : Returns a  ScopeManager  of  RunUser s that have access to the scope. If  leader  is True and the scope is a world, returns all RunUsers for the World's Run  .get_users(leader=False) : returns a list of user ids (not runuser ids) from  get_runusers .",
            "title": "Traversing Scopes"
        },
        {
            "location": "/services/modelservice/scopemanager/",
            "text": "ScopeManager\n\n\nCollection of scopes are usually returned as a ScopeManager.\n\n\nA \nScopeManager\n behaves like a list (ie: you can iterate on them, use the \nin\n operator),\nand allows you to operate on collections of scopes. However, there is no particular ordering to a ScopeManager's scopes.\n\n\nFiltering\n\n\nScopeManager.filter(**kwargs)\n will return a new \nScopeManager\n with only the scopes that match the conditions.\n\n\nTo retrieve Runuser scopes that have \n.json['world']\n set to \n3\n for example use:\n\n\nrunusers\n \n=\n \nself\n.\ngame\n.\nscopes\n[\n'runuser'\n]\n.\nfilter\n(\nworld\n=\n3\n)\n\n\n\n\n\n\nScopeManager.for_user(user)\n will return only the subset of scopes that a specific user\n(not to be confused with \nRunUser\n) has access to through their \nRunUser\ns.\n\n\nSimilar to \n.filter\n, \n.get(**kwargs)\n will retrieve only one scope matching the conditions.\n\n\nIf no scope can found, \nScopeManager.ScopeNotFound\n will be raised.\n\n\nIf more than one scope is found, \nScopeManager.MultipleScopesFound\n will be raised.\n\n\nExample:\n\n\nmyscopes\n.\nget\n(\nworld\n=\n3\n)\n  \n# return a scopes that has `.json['world']` set to `3`.\n\n\n\n\n\n\n.count()\n will return the number of scopes in the manager.\n\n\nEditing\n\n\nJust like list, \nScopeManagers\n can be combined using the \n+\n operator:\n\n\nmy_scopes\n \n=\n \nmanager1\n \n+\n \nmanager2\n\n\n\n\n\n\nThey also provide an \nappend(*scopes)\n method:\n\n\nmy_scopes\n \n=\n \nmanager1\n.\nappend\n(\nscope1\n,\n \nscope2\n)\n\n\n\n\n\n\nFinally, you can clear out a manager with \n.reset()\n.",
            "title": "Scope Manager"
        },
        {
            "location": "/services/modelservice/scopemanager/#scopemanager",
            "text": "Collection of scopes are usually returned as a ScopeManager.  A  ScopeManager  behaves like a list (ie: you can iterate on them, use the  in  operator),\nand allows you to operate on collections of scopes. However, there is no particular ordering to a ScopeManager's scopes.",
            "title": "ScopeManager"
        },
        {
            "location": "/services/modelservice/scopemanager/#filtering",
            "text": "ScopeManager.filter(**kwargs)  will return a new  ScopeManager  with only the scopes that match the conditions.  To retrieve Runuser scopes that have  .json['world']  set to  3  for example use:  runusers   =   self . game . scopes [ 'runuser' ] . filter ( world = 3 )   ScopeManager.for_user(user)  will return only the subset of scopes that a specific user\n(not to be confused with  RunUser ) has access to through their  RunUser s.  Similar to  .filter ,  .get(**kwargs)  will retrieve only one scope matching the conditions.  If no scope can found,  ScopeManager.ScopeNotFound  will be raised.  If more than one scope is found,  ScopeManager.MultipleScopesFound  will be raised.  Example:  myscopes . get ( world = 3 )    # return a scopes that has `.json['world']` set to `3`.   .count()  will return the number of scopes in the manager.",
            "title": "Filtering"
        },
        {
            "location": "/services/modelservice/scopemanager/#editing",
            "text": "Just like list,  ScopeManagers  can be combined using the  +  operator:  my_scopes   =   manager1   +   manager2   They also provide an  append(*scopes)  method:  my_scopes   =   manager1 . append ( scope1 ,   scope2 )   Finally, you can clear out a manager with  .reset() .",
            "title": "Editing"
        },
        {
            "location": "/services/modelservice/running/",
            "text": "Running the model service\n\n\n$ manage.py run_modelservice",
            "title": "Running"
        },
        {
            "location": "/services/modelservice/running/#running-the-model-service",
            "text": "$ manage.py run_modelservice",
            "title": "Running the model service"
        },
        {
            "location": "/services/modelservice/settings/",
            "text": "Settings\n\n\nRequired settings\n\n\nSIMPL_GAMES_URL\n \n=\n \n'http://localhost:9000'\n\n\nSIMPL_GAMES_AUTH\n \n=\n \n(\n'system'\n,\n \n'System!1'\n)\n\n\nROOT_TOPIC\n \n=\n \n'com.example'",
            "title": "Setting"
        },
        {
            "location": "/services/modelservice/settings/#settings",
            "text": "",
            "title": "Settings"
        },
        {
            "location": "/services/modelservice/settings/#required-settings",
            "text": "SIMPL_GAMES_URL   =   'http://localhost:9000'  SIMPL_GAMES_AUTH   =   ( 'system' ,   'System!1' )  ROOT_TOPIC   =   'com.example'",
            "title": "Required settings"
        },
        {
            "location": "/services/modelservice/simpl/",
            "text": "The simpl client\n\n\nThe \nmodelservice.simpl.games_client\n class provides a generic asynchronous REST API client that you can use to\ninterface with the Simpl-Games-API service.\n\n\nfrom\n \nmodelservice.simpl\n \nimport\n \ngames_client\n\n\n\nasync\n \nwith\n \ngames_client\n \nas\n \napi_session\n:\n\n\n    \nusers\n \n=\n \nawait\n \napi_session\n.\nusers\n.\nall\n()\n\n\n    \nworld_users\n \n=\n \nawait\n \napi_session\n.\nusers\n.\nfilter\n(\nworld\n=\n35\n)\n\n\n    \nuser\n \n=\n \nawait\n \napi_session\n.\nusers\n.\nget\n(\nemail\n=\n'myuser@example.com'\n)\n\n\n    \nuser\n.\nfirst_name\n \n=\n \n'Jessie'\n\n\n    \nawait\n \nuser\n.\nsave\n()\n\n\n\n\n\n\nEndpoint methods\n\n\n\n\n.create_or_update(**kwargs)\n\n\n.create(**kwargs)\n\n\n.all()\n\n\n.filter(**kwargs)\n\n\n.get(**kwargs)\n\n\n\n\nResource methods\n\n\n\n\n.save()\n\n\n.delete()\n\n\n\n\nResource attributes\n\n\n\n\n.payload\n: a \ndict\n containg the data returned in the response body.\n\n\n\n\nExceptions\n\n\nAll exceptions are subclasses of \nValueError\n.\n\n\n\n\nMultipleResourcesFound\n\n\nResourceNotFound\n\n\nNotAuthenticatedError\n\n\nHTTPError",
            "title": "Simpl client"
        },
        {
            "location": "/services/modelservice/simpl/#the-simpl-client",
            "text": "The  modelservice.simpl.games_client  class provides a generic asynchronous REST API client that you can use to\ninterface with the Simpl-Games-API service.  from   modelservice.simpl   import   games_client  async   with   games_client   as   api_session : \n\n     users   =   await   api_session . users . all () \n\n     world_users   =   await   api_session . users . filter ( world = 35 ) \n\n     user   =   await   api_session . users . get ( email = 'myuser@example.com' ) \n\n     user . first_name   =   'Jessie' \n\n     await   user . save ()",
            "title": "The simpl client"
        },
        {
            "location": "/services/modelservice/simpl/#endpoint-methods",
            "text": ".create_or_update(**kwargs)  .create(**kwargs)  .all()  .filter(**kwargs)  .get(**kwargs)",
            "title": "Endpoint methods"
        },
        {
            "location": "/services/modelservice/simpl/#resource-methods",
            "text": ".save()  .delete()",
            "title": "Resource methods"
        },
        {
            "location": "/services/modelservice/simpl/#resource-attributes",
            "text": ".payload : a  dict  containg the data returned in the response body.",
            "title": "Resource attributes"
        },
        {
            "location": "/services/modelservice/simpl/#exceptions",
            "text": "All exceptions are subclasses of  ValueError .   MultipleResourcesFound  ResourceNotFound  NotAuthenticatedError  HTTPError",
            "title": "Exceptions"
        },
        {
            "location": "/services/modelservice/webhooks/",
            "text": "Registering functions with hooks\n\n\nInside your Django app, create a file called \nwebhooks.py\n with the following content:\n\n\nfrom\n \nmodelservice.webhooks\n \nimport\n \nhook\n\n\n\n@hook\n(\n'SET_PHASE'\n)\n\n\ndef\n \nmyfunc\n(\npayload\n):\n\n    \ndo_something\n()\n\n\n\n\n\n\nwebhooks.py\n modules are automatically discovered and imported.\n\n\nYou can register multiple functions with the same event, but the order in which they are executed is undetermined.",
            "title": "Webhooks"
        },
        {
            "location": "/services/modelservice/webhooks/#registering-functions-with-hooks",
            "text": "Inside your Django app, create a file called  webhooks.py  with the following content:  from   modelservice.webhooks   import   hook  @hook ( 'SET_PHASE' )  def   myfunc ( payload ): \n     do_something ()   webhooks.py  modules are automatically discovered and imported.  You can register multiple functions with the same event, but the order in which they are executed is undetermined.",
            "title": "Registering functions with hooks"
        },
        {
            "location": "/services/simpl-react/overview/",
            "text": "Overview\n\n\nAbstraction Layers\n\n\nThis module is conceptually organized in two layers:\n\n\n\n\nThe \nwamp\n layer. Includes primitives to publish/subcribe and remote call via the wamp protocol.\n\n\nThe \nsimpl\n layer. Uses the \nwamp\n layer to provide automatic data binding ans synchronization with \nScope\ns defined in the modelservice implementation, provided it uses \nScope\ns from the \nmodelservice\n Python package.\n\n\n\n\nYou will mostly work on the \nsimpl\n layer, and build your app by writing Presentational Components and tying up data to Smart Components by using decorators.\n\n\nDecorators\n\n\n\n\nsimpl/lib/decorators/pubsub/publishes\n\n\nsimpl/lib/decorators/pubsub/subscribes\n\n\nsimpl/lib/decorators/rpc/calls\n\n\nsimpl/lib/decorators/simpl\n\n\n\n\nComponents\n\n\nPresentational Components\n\n\nPresentational components only provide the necessary markup to render the UI.\n\n\nSmart Component\n\n\nSmart Components provide data and functions (\nprops\n) and pass them down to their Presentational component.\n\n\nWAMP Components\n\n\nWamp Components are convenience components that wrap a Smart or presentational components to provide them wamp-relative functionality, such as listening or publishing to a topic or calling a remote procedure on the model service \n\n\n\n\nTopicPublisher\n\n\nTopicSubscriber\n\n\nRPCCaller\n\n\n\n\nReducers\n\n\nThe \nSimpl.reducers.combined.simplReducers\n reducer\n\n\nThis reducer provides the \nsimpl\n and \nrouter\n reducers necessary for connecting to the modelservice and keeping state updated.\n\n\nimport\n \n{\nsimplReducers\n}\n \nfrom\n \n'simpl/lib/reducers/combined'\n;\n\n\n\n\nconst\n \nreducers\n \n=\n \nsimplReducers\n({});\n\n\n\nexport\n \ndefault\n \nreducers\n;\n\n\n\n\n\n\nYou can add your own reducers to it by passing them as arguments:\n\n\nimport\n \n{\nsimplReducers\n}\n \nfrom\n \n'simpl/lib/reducers/combined'\n;\n\n\n\nimport\n \nmyreducer\n \nfrom\n \n'../MyReducers'\n\n\n\nconst\n \nreducers\n \n=\n \nsimplReducers\n({\n\n  \nmyreducer\n,\n\n\n});\n\n\n\nexport\n \ndefault\n \nreducers\n;\n\n\n\n\n\n\nStores\n\n\nThe \nSimpl.stores.finalCreateStoreFactory\n\n\nThis factory returns a \ncreateStore\n function with all the necessary devTools configured according to the environment.\n\n\nstores/AppStore.js\n\n\nimport\n \n{\n \ncreateStore\n \n}\n \nfrom\n \n'redux'\n\n\n\nimport\n \n{\nfinalCreateStoreFactory\n}\n \nfrom\n \n'simpl/lib/stores'\n;\n\n\n\nimport\n \nrootReducer\n \nfrom\n \n'../reducers/combined/appReducers'\n\n\n\nexport\n \ndefault\n \nfunction\n \nconfigureStore\n(\ninitialState\n)\n \n{\n\n\n  \nconst\n \nfinalCreateStore\n \n=\n \nfinalCreateStoreFactory\n(\nprocess\n.\nenv\n.\nNODE_ENV\n)\n\n  \nconst\n \nstore\n \n=\n \nfinalCreateStore\n(\nrootReducer\n,\n \ninitialState\n);\n\n\n  \nreturn\n \nstore\n;\n\n\n};\n\n\n\n\n\n\napps/main.js\n\n\nimport\n \nconfigureStore\n \nfrom\n \n'../stores/AppStore'\n\n\n\n\nconst\n \nstore\n \n=\n \nconfigureStore\n();",
            "title": "Overview"
        },
        {
            "location": "/services/simpl-react/overview/#overview",
            "text": "",
            "title": "Overview"
        },
        {
            "location": "/services/simpl-react/overview/#abstraction-layers",
            "text": "This module is conceptually organized in two layers:   The  wamp  layer. Includes primitives to publish/subcribe and remote call via the wamp protocol.  The  simpl  layer. Uses the  wamp  layer to provide automatic data binding ans synchronization with  Scope s defined in the modelservice implementation, provided it uses  Scope s from the  modelservice  Python package.   You will mostly work on the  simpl  layer, and build your app by writing Presentational Components and tying up data to Smart Components by using decorators.",
            "title": "Abstraction Layers"
        },
        {
            "location": "/services/simpl-react/overview/#decorators",
            "text": "simpl/lib/decorators/pubsub/publishes  simpl/lib/decorators/pubsub/subscribes  simpl/lib/decorators/rpc/calls  simpl/lib/decorators/simpl",
            "title": "Decorators"
        },
        {
            "location": "/services/simpl-react/overview/#components",
            "text": "",
            "title": "Components"
        },
        {
            "location": "/services/simpl-react/overview/#presentational-components",
            "text": "Presentational components only provide the necessary markup to render the UI.",
            "title": "Presentational Components"
        },
        {
            "location": "/services/simpl-react/overview/#smart-component",
            "text": "Smart Components provide data and functions ( props ) and pass them down to their Presentational component.",
            "title": "Smart Component"
        },
        {
            "location": "/services/simpl-react/overview/#wamp-components",
            "text": "Wamp Components are convenience components that wrap a Smart or presentational components to provide them wamp-relative functionality, such as listening or publishing to a topic or calling a remote procedure on the model service    TopicPublisher  TopicSubscriber  RPCCaller",
            "title": "WAMP Components"
        },
        {
            "location": "/services/simpl-react/overview/#reducers",
            "text": "",
            "title": "Reducers"
        },
        {
            "location": "/services/simpl-react/overview/#the-simplreducerscombinedsimplreducers-reducer",
            "text": "This reducer provides the  simpl  and  router  reducers necessary for connecting to the modelservice and keeping state updated.  import   { simplReducers }   from   'simpl/lib/reducers/combined' ;  const   reducers   =   simplReducers ({});  export   default   reducers ;   You can add your own reducers to it by passing them as arguments:  import   { simplReducers }   from   'simpl/lib/reducers/combined' ;  import   myreducer   from   '../MyReducers'  const   reducers   =   simplReducers ({ \n   myreducer ,  });  export   default   reducers ;",
            "title": "The Simpl.reducers.combined.simplReducers reducer"
        },
        {
            "location": "/services/simpl-react/overview/#stores",
            "text": "",
            "title": "Stores"
        },
        {
            "location": "/services/simpl-react/overview/#the-simplstoresfinalcreatestorefactory",
            "text": "This factory returns a  createStore  function with all the necessary devTools configured according to the environment.  stores/AppStore.js  import   {   createStore   }   from   'redux'  import   { finalCreateStoreFactory }   from   'simpl/lib/stores' ;  import   rootReducer   from   '../reducers/combined/appReducers'  export   default   function   configureStore ( initialState )   { \n\n   const   finalCreateStore   =   finalCreateStoreFactory ( process . env . NODE_ENV ) \n   const   store   =   finalCreateStore ( rootReducer ,   initialState ); \n\n   return   store ;  };   apps/main.js  import   configureStore   from   '../stores/AppStore'  const   store   =   configureStore ();",
            "title": "The Simpl.stores.finalCreateStoreFactory"
        },
        {
            "location": "/services/simpl-react/actions/",
            "text": "Actions\n\n\nTo create an action, you can use the \ncreateAction\n convenience function from \nredux-actions\n.\n\n\nactions/myactions.js\n\n\nimport\n \n{\n \ncreateAction\n \n}\n \nfrom\n \n'redux-actions'\n;\n\n\n\n\nexport\n \nconst\n \nmyAction\n \n=\n \ncreateAction\n(\n'MY_ACTION'\n);\n\n\n\n\n\n\nThe function will create an action that serializes to the passed action name, and can be directly imported and used as a key in a reducer:\n\n\nreducers/myreducer.js\n\n\nimport\n \n{\n \ncreateReducer\n \n}\n \nfrom\n \n'redux-create-reducer'\n;\n\n\nimport\n \nrecycleState\n \nfrom\n \n'redux-recycle'\n;\n\n\n\nimport\n \n{\n \nrecyleStateAction\n \n}\n \nfrom\n \n'simpl/lib/actions/state'\n;\n\n\n\nimport\n \n{\n \nmyAction\n \n}\n \nfrom\n \n'../actions/myactions'\n;\n\n\n\n\nconst\n \nsimpl\n \n=\n \nrecycleState\n(\ncreateReducer\n(\ninitial\n,\n \n{\n\n  \n[\nmyAction\n](\nstate\n,\n \naction\n)\n \n{\n\n    \n// update state accordingly...\n\n    \nreturn\n \nObject\n.\nassign\n({},\n \nstate\n,\n \naction\n.\npayload\n);\n\n  \n},\n\n\n}),\n \n`\n${\nrecyleStateAction\n}\n`\n);\n\n\n\n\n\n\nPubSub\n\n\nTo create an action that publishes to a WAMP topic, you should use the Autobahn client included with \nsimpl\n:\n\n\nactions/myactions.js\n\n\nimport\n \n{\n \ncreateAction\n \n}\n \nfrom\n \n'redux-actions'\n;\n\n\nimport\n \nAutobahnReact\n \nfrom\n \n'simpl/lib/autobahn'\n;\n\n\n\n\nexport\n \nconst\n \nmyAction\n \n=\n \ncreateAction\n(\n'MY_ACTION'\n,\n \n(\nsome_scope\n,\n \n...\nargs\n)\n \n=>\n\n    \nAutobahnReact\n.\npublish\n(\n`model:model.\n${\nsome_scope\n.\nresource_name\n}\n.\n${\nsome_scope\n.\nid\n}\n.topic_name`\n,\n \nargs\n)\n\n\n);\n\n\n\n\n\n\nSince publishing to a topic does not return any value, and \"completes\" before anything is done on the server side, there is very little reason to catch the action in a reducer.\n\n\nRPC\n\n\nTo create an action that calss a WAMP topic, you should use the Autobahn client included with \nsimpl\n:\n\n\nactions/myactions.js\n\n\nimport\n \n{\n \ncreateAction\n \n}\n \nfrom\n \n'redux-actions'\n;\n\n\nimport\n \nAutobahnReact\n \nfrom\n \n'simpl/lib/autobahn'\n;\n\n\n\n\nexport\n \nconst\n \ngetSomeData\n \n=\n \ncreateAction\n(\n'GET_SOME_DATA'\n,\n \n(\nscope\n,\n \n...\nargs\n)\n \n=>\n \n(\n\n  \nAutobahnReact\n.\ncall\n(\n`\n${\nscope\n}\n.get_some_data`\n,\n \nargs\n)\n\n\n));\n\n\n\n\n\n\nThe action's \npayload\n will contain the value returned by the remote procedure:\n\n\nreducers/myreducer.js\n\n\nimport\n \n{\n \ncreateReducer\n \n}\n \nfrom\n \n'redux-create-reducer'\n;\n\n\nimport\n \nrecycleState\n \nfrom\n \n'redux-recycle'\n;\n\n\n\nimport\n \n{\n \nrecyleStateAction\n \n}\n \nfrom\n \n'simpl/lib/actions/state'\n\n\nimport\n \n{\n \ngetSomeData\n \n}\n \nfrom\n \n'../actions/myactions'\n;\n\n\n\n\nconst\n \nsimpl\n \n=\n \nrecycleState\n(\ncreateReducer\n(\ninitial\n,\n \n{\n\n  \n[\ngetSomeData\n](\nstate\n,\n \naction\n)\n \n{\n\n\n    \nreturn\n \nObject\n.\nassign\n({},\n \nstate\n,\n \naction\n.\npayload\n);\n\n  \n},\n\n\n}),\n \n`\n${\nrecyleStateAction\n}\n`\n);\n\n\n\n\n\n\nChain RPC promises\n\n\nThe action returns a promise which will be resolved with the returned value. This means tha t you can chain to the action to dispatch further actions after the call completes:\n\n\nMyContainer.react.js\n\n\nimport\n \n{\n \nconnect\n \n}\n \nfrom\n \n'react-redux'\n;\n\n\nimport\n \n{\n \ngetSomeData\n,\n \nsomeOtherAction\n \n}\n \nfrom\n \n'../actions/myactions'\n;\n\n\n\nimport\n \n{\n \nMyComponent\n \n}\n \nfrom\n \n'../components/MyComponent.react'\n;\n\n\n\n\nfunction\n \nmapDispatchToProps\n(\ndispatch\n)\n \n{\n\n    \nreturn\n \n{\n\n        \nmyHandler\n:\n \nfunction\n(\nsomeValue\n)\n \n{\n\n            \ndispatch\n(\ngetSomeData\n(\nsomeValue\n)).\nthen\n(\n\n                \n(\ncallResult\n)\n \n=>\n \ndispatch\n(\nsomeOtherAction\n(\ncallResult\n))\n\n            \n)\n\n        \n}\n\n    \n};\n\n\n}\n\n\n\nconst\n \nMyContainer\n \n=\n \nconnect\n(\n\n    \nnull\n,\n\n    \nmapDispatchToProps\n\n\n)(\nMyComponent\n);\n\n\n\nexport\n \ndefault\n \nMyContainer\n;",
            "title": "Actions"
        },
        {
            "location": "/services/simpl-react/actions/#actions",
            "text": "To create an action, you can use the  createAction  convenience function from  redux-actions .  actions/myactions.js  import   {   createAction   }   from   'redux-actions' ;  export   const   myAction   =   createAction ( 'MY_ACTION' );   The function will create an action that serializes to the passed action name, and can be directly imported and used as a key in a reducer:  reducers/myreducer.js  import   {   createReducer   }   from   'redux-create-reducer' ;  import   recycleState   from   'redux-recycle' ;  import   {   recyleStateAction   }   from   'simpl/lib/actions/state' ;  import   {   myAction   }   from   '../actions/myactions' ;  const   simpl   =   recycleState ( createReducer ( initial ,   { \n   [ myAction ]( state ,   action )   { \n     // update state accordingly... \n     return   Object . assign ({},   state ,   action . payload ); \n   },  }),   ` ${ recyleStateAction } ` );",
            "title": "Actions"
        },
        {
            "location": "/services/simpl-react/actions/#pubsub",
            "text": "To create an action that publishes to a WAMP topic, you should use the Autobahn client included with  simpl :  actions/myactions.js  import   {   createAction   }   from   'redux-actions' ;  import   AutobahnReact   from   'simpl/lib/autobahn' ;  export   const   myAction   =   createAction ( 'MY_ACTION' ,   ( some_scope ,   ... args )   => \n     AutobahnReact . publish ( `model:model. ${ some_scope . resource_name } . ${ some_scope . id } .topic_name` ,   args )  );   Since publishing to a topic does not return any value, and \"completes\" before anything is done on the server side, there is very little reason to catch the action in a reducer.",
            "title": "PubSub"
        },
        {
            "location": "/services/simpl-react/actions/#rpc",
            "text": "To create an action that calss a WAMP topic, you should use the Autobahn client included with  simpl :  actions/myactions.js  import   {   createAction   }   from   'redux-actions' ;  import   AutobahnReact   from   'simpl/lib/autobahn' ;  export   const   getSomeData   =   createAction ( 'GET_SOME_DATA' ,   ( scope ,   ... args )   =>   ( \n   AutobahnReact . call ( ` ${ scope } .get_some_data` ,   args )  ));   The action's  payload  will contain the value returned by the remote procedure:  reducers/myreducer.js  import   {   createReducer   }   from   'redux-create-reducer' ;  import   recycleState   from   'redux-recycle' ;  import   {   recyleStateAction   }   from   'simpl/lib/actions/state'  import   {   getSomeData   }   from   '../actions/myactions' ;  const   simpl   =   recycleState ( createReducer ( initial ,   { \n   [ getSomeData ]( state ,   action )   { \n\n     return   Object . assign ({},   state ,   action . payload ); \n   },  }),   ` ${ recyleStateAction } ` );",
            "title": "RPC"
        },
        {
            "location": "/services/simpl-react/actions/#chain-rpc-promises",
            "text": "The action returns a promise which will be resolved with the returned value. This means tha t you can chain to the action to dispatch further actions after the call completes:  MyContainer.react.js  import   {   connect   }   from   'react-redux' ;  import   {   getSomeData ,   someOtherAction   }   from   '../actions/myactions' ;  import   {   MyComponent   }   from   '../components/MyComponent.react' ;  function   mapDispatchToProps ( dispatch )   { \n     return   { \n         myHandler :   function ( someValue )   { \n             dispatch ( getSomeData ( someValue )). then ( \n                 ( callResult )   =>   dispatch ( someOtherAction ( callResult )) \n             ) \n         } \n     };  }  const   MyContainer   =   connect ( \n     null , \n     mapDispatchToProps  )( MyComponent );  export   default   MyContainer ;",
            "title": "Chain RPC promises"
        }
    ]
}